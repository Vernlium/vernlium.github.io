<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-wukong.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-wukong.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vernlium.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="课程笔记 本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点： - 边缘检测 - 卷积的实现 - padding - pooling - stride">
<meta property="og:type" content="article">
<meta property="og:title" content="coursera-deeplearning-ai-c4-week1">
<meta property="og:url" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/index.html">
<meta property="og:site_name" content="Vernlium">
<meta property="og:description" content="课程笔记 本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点： - 边缘检测 - 卷积的实现 - padding - pooling - stride">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_and_horizontal_edge_detection.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/stride2.gif">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_convolution.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/mulit_channel_convolution.gif">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/multiple_filters.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_notation.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/example_convnet.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/maxpool_animation.gif">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/neural_network_example.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/lenet_5_parameters.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/putting_it_together.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/model.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_nn.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/PAD.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/Convolution_schematic.gif">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_kiank.gif">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/vert_horiz_kiank.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/max_pool1.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/a_pool.png">
<meta property="og:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/SIGNS.png">
<meta property="article:published_time" content="2018-10-14T23:16:40.000Z">
<meta property="article:modified_time" content="2020-10-17T13:11:22.855Z">
<meta property="article:author" content="张阿楠">
<meta property="article:tag" content="deeplearning.ai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg">

<link rel="canonical" href="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>coursera-deeplearning-ai-c4-week1 | Vernlium</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vernlium</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Keep codeing and thinking!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wukong.png">
      <meta itemprop="name" content="张阿楠">
      <meta itemprop="description" content="Keep codeing and thinking!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vernlium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          coursera-deeplearning-ai-c4-week1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 07:16:40" itemprop="dateCreated datePublished" datetime="2018-10-15T07:16:40+08:00">2018-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-17 21:11:22" itemprop="dateModified" datetime="2020-10-17T21:11:22+08:00">2020-10-17</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="课程笔记">课程笔记</h2>
<p>本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点： - 边缘检测 - 卷积的实现 - padding - pooling - stride</p>
<p>学习目标：</p>
<ul>
<li>Understand the convolution operation</li>
<li>Understand the pooling operation</li>
<li>Remember the vocabulary used in convolutional neural network (padding, stride, filter, ...)</li>
<li>Build a convolutional neural network for image multi-class classification</li>
</ul>
<h3 id="convolutional-neural-networks">Convolutional Neural Networks</h3>
<h4 id="computer-vision">Computer Vision</h4>
<p>计算机视觉的应用：</p>
<ul>
<li>Image Classification</li>
<li>Object detection</li>
<li>Image Style Transfer</li>
</ul>
<h4 id="edge-detection-example">Edge Detection Example</h4>
<p>通过特定的filter，可以检测出特定的边缘。比如，下图中的filter可以检测出垂直方向的边缘。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg" class="" title="Vertical Edge Detection">
<h4 id="more-edge-detection">More Edge Detection</h4>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_and_horizontal_edge_detection.jpg" class="" title="Vertical and Horizontal Edge Detection">
<p>在深度学习领域，要通过训练学习的方式，学习得到filter来检测不同的边缘。</p>
<h4 id="padding">Padding</h4>
<p>上面给的filter，会把结果图像的尺寸变小，所以通过padding操作，在输入图像边缘填充的方式，使得原图像变大，以保持输出尺寸和原图像大小一致。</p>
<p>输出图像的尺寸计算公式为：$ n - f +1 $</p>
<p>加入padding后，输出图像的尺寸计算公式为：$ n + 2p - f + 1 $</p>
<p>为了使输出图像尺寸保持不变，即$ n + 2p - f + 1 = n $，所以</p>
<p><span class="math display">\[ p = \frac{ f - 1 }{2}  \]</span></p>
<p>有两种padding方式：</p>
<ul>
<li><strong>VALID</strong>: 不进行padding，输出图像的尺寸计算公式为：$ n - f +1 $</li>
<li><strong>SAME</strong>： 进行padding，大小为：<span class="math display">\[ p = \frac{ f - 1 }{2}  \]</span></li>
</ul>
<blockquote>
<p>注：深度学习领域，一般情况下f取值为奇数，比如1、3、5、7等。否则会出现不对称填充。</p>
</blockquote>
<p>Tensorflow中，VALID padding的实现如下：</p>
<p><span class="math display">\[ \text{padding along height} = P_h = max((\text{output height}-1)*S_h + F_h - H, 0) \]</span></p>
<p><span class="math display">\[ \text{padding along width} = P_w = max((\text{output width}-1)*S_w + F_w - W, 0) \]</span></p>
<p><span class="math display">\[ \text{padding top} = P_t = Floor(\dfrac{P_h}{2}) \qquad \qquad \text{padding left} = P_l = Floor(\dfrac{P_w}{2}) \]</span></p>
<p><span class="math display">\[ \text{padding bottom} = P_h - P_t \qquad \qquad \text{padding right} = P_w - P_l \]</span></p>
<p>代码实现为：</p>
<p>For the 'SAME' padding, the output height and width are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height &#x3D; ceil(float(in_height) &#x2F; float(strides[1]))</span><br><span class="line">out_width  &#x3D; ceil(float(in_width) &#x2F; float(strides[2]))</span><br></pre></td></tr></table></figure>
<p>and the padding on the top and left are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pad_along_height &#x3D; max((out_height - 1) * strides[1] + filter_height - in_height, 0)</span><br><span class="line">pad_along_width &#x3D; max((out_width - 1) * strides[2] + filter_width - in_width, 0)</span><br><span class="line">pad_top &#x3D; pad_along_height &#x2F;&#x2F; 2</span><br><span class="line">pad_bottom &#x3D; pad_along_height - pad_top</span><br><span class="line">pad_left &#x3D; pad_along_width &#x2F;&#x2F; 2</span><br><span class="line">pad_right &#x3D; pad_along_width - pad_left</span><br></pre></td></tr></table></figure>
<p>For the 'VALID' padding, the output height and width are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_height &#x3D; ceil(float(in_height - filter_height + 1) &#x2F; float(strides[1]))</span><br><span class="line">out_width  &#x3D; ceil(float(in_width - filter_width + 1) &#x2F; float(strides[2]))</span><br></pre></td></tr></table></figure>
<p>and the padding values are always zero.</p>
<h4 id="strided-convolutions">Strided Convolutions</h4>
<p>步长是卷积核进行计算是每次跳跃的长度。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/stride2.gif" class="" title="Convolution with stride 2">
<p><span class="math display">\[
\text{output width} = \dfrac{W-F_w+2P}{S_w}+1
\]</span></p>
<p><span class="math display">\[
\text{output height} = \dfrac{H-F_h+2P}{S_h}+1
\]</span></p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_convolution.jpg" class="" title="Summary of convolution">
<h4 id="convolutions-over-volume">Convolutions Over Volume</h4>
<p>上面讲的卷积是二维的，在正常卷积神经网络中，卷积一般是3维的，也就是多channel的，通过下图可以理解多channel卷积的计算。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/mulit_channel_convolution.gif" class="" title="Multi-channel input convolution">
<p>上图中，输入是一副图片，3个通道（RGB），filter也对应3个通道，计算后得到一个2维的结果。如果想要结果也是多维的，则需要多个fliter，如下图：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/multiple_filters.jpg" class="" title="Multiple filters">
<h4 id="one-layer-of-a-convolutional-network">One Layer of a Convolutional Network</h4>
<p>卷积层和之前讲到的神经网络的典型计算公式是类似的。</p>
<p>下图是各种卷积层的概念的表达方式：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_notation.jpg" class="" title="Summary of notation">
<h4 id="simple-convolutional-network-example">Simple Convolutional Network Example</h4>
<p>下图是一个典型卷积网络的例子：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/example_convnet.jpg" class="" title="Example ConvNet">
<p>Types of layer in a convolutional network:</p>
<ul>
<li>Convolution</li>
<li>Pooling</li>
<li>Fully connected</li>
</ul>
<h4 id="pooling-layers">Pooling Layers</h4>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/maxpool_animation.gif" class="" title="Maxpooling">
<p>Max Pooling的一个有趣的特性是：它有一套超参，但是它没有任何参数需要学习。没有任何需要梯度相加算法学习的东西，一旦确定了$ f <span class="math inline">\(和\)</span> s $就确定了计算,而且梯度下降算法不会对其有任何改变。</p>
<p>上面卷积层计算输出size的公式同样在这里适用。</p>
<p>还有一种是Average Pooling，就是求filter*filter内的平均值。相比来说，Max Pooling用的更多。</p>
<p>Pooling层的超参数有如下三个：</p>
<ul>
<li>f : filter size</li>
<li>s : stride</li>
<li>Max or average pooling</li>
</ul>
<p>不需要通过学习即可确定。</p>
<h4 id="cnn-example">CNN Example</h4>
<p>下图是一个卷积神经网络的示例，是基于LeNet-5网络改造的。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/neural_network_example.jpg" class="" title="Neural Network Example">
<blockquote>
<p>注： LeNet-5网络是Yann LeCun在1998年设计的用于手写数字识别的卷积神经网络,当年美国大多数银行就是用它来识别支票上面的手写数字的,它是早期卷积神经网络中最有代表性的实验系统之一。可参考：<a target="_blank" rel="noopener" href="http://yann.lecun.com/exdb/lenet/" class="uri">http://yann.lecun.com/exdb/lenet/</a> LeNet-5的数据集是MNIST，一般也是各种深度学习框架的入门示例，学习起来很好理解，也很简单，作为入门的示例非常好。 这个网站<a target="_blank" rel="noopener" href="http://scs.ryerson.ca/~aharley/vis/conv/" class="uri">http://scs.ryerson.ca/~aharley/vis/conv/</a>做了一个3D展示LeNet-5网络每一层的效果，看起来很清晰，推荐。</p>
</blockquote>
<p>下图是上面的LeNet-5网络的每一层的参数个数表，可以看出，卷积层的参数相比于全连接层是非常少的，这也是卷积层的优势所在。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/lenet_5_parameters.jpg" class="" title="LeNet-5 Parameters">
<p>关于超参数组选择的建议：</p>
<p>不要试着创造你自己的超参数组，而是查看文献，看看其他人使用的超参数，从中选一组适用于其他人的超参数，很可能它也适用于你的应用。</p>
<p>通常随着神经网络的深入，高度<span class="math inline">\(n_h\)</span>和宽度<span class="math inline">\(n_w\)</span>会减小。然而通道数量会增加，最后是全连通网络层。另一类常见的神经网络模型是，一个或多个卷积层接着一层池化层，再接着一个或多个卷积层叠加一层池化层，然后叠加几层全连接，也许最后还叠加一个Softmax层。</p>
<h4 id="why-convolutions">Why Convolutions?</h4>
<p>卷积网络有效的原因：</p>
<ul>
<li><strong>Parameter sharing</strong>（参数共享）: A feature detector (such as a vertical edge detector) that’s useful in one part of the image is probably useful in another part of the image.</li>
<li><strong>Sparsity of connections</strong>(稀疏式联系): In each layer, each output value depends only on a small number of inputs.</li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/putting_it_together.jpg" class="" title="Putting it together">
<h2 id="编程练习">编程练习</h2>
<h3 id="convolutional-neural-networks-step-by-step">Convolutional Neural Networks: Step by Step</h3>
<p>Welcome to Course 4's first assignment! In this assignment, you will implement convolutional (CONV) and pooling (POOL) layers in numpy, including both forward propagation and (optionally) backward propagation.</p>
<p><strong>Notation</strong>: - Superscript <span class="math inline">\([l]\)</span> denotes an object of the <span class="math inline">\(l^{th}\)</span> layer. - Example: <span class="math inline">\(a^{[4]}\)</span> is the <span class="math inline">\(4^{th}\)</span> layer activation. <span class="math inline">\(W^{[5]}\)</span> and <span class="math inline">\(b^{[5]}\)</span> are the <span class="math inline">\(5^{th}\)</span> layer parameters.</p>
<ul>
<li>Superscript <span class="math inline">\((i)\)</span> denotes an object from the <span class="math inline">\(i^{th}\)</span> example.
<ul>
<li>Example: <span class="math inline">\(x^{(i)}\)</span> is the <span class="math inline">\(i^{th}\)</span> training example input.</li>
</ul></li>
<li>Lowerscript <span class="math inline">\(i\)</span> denotes the <span class="math inline">\(i^{th}\)</span> entry of a vector.
<ul>
<li>Example: <span class="math inline">\(a^{[l]}_i\)</span> denotes the <span class="math inline">\(i^{th}\)</span> entry of the activations in layer <span class="math inline">\(l\)</span>, assuming this is a fully connected (FC) layer.</li>
</ul></li>
<li><span class="math inline">\(n_H\)</span>, <span class="math inline">\(n_W\)</span> and <span class="math inline">\(n_C\)</span> denote respectively the height, width and number of channels of a given layer. If you want to reference a specific layer <span class="math inline">\(l\)</span>, you can also write <span class="math inline">\(n_H^{[l]}\)</span>, <span class="math inline">\(n_W^{[l]}\)</span>, <span class="math inline">\(n_C^{[l]}\)</span>.</li>
<li><span class="math inline">\(n_{H_{prev}}\)</span>, <span class="math inline">\(n_{W_{prev}}\)</span> and <span class="math inline">\(n_{C_{prev}}\)</span> denote respectively the height, width and number of channels of the previous layer. If referencing a specific layer <span class="math inline">\(l\)</span>, this could also be denoted <span class="math inline">\(n_H^{[l-1]}\)</span>, <span class="math inline">\(n_W^{[l-1]}\)</span>, <span class="math inline">\(n_C^{[l-1]}\)</span>.</li>
</ul>
<p>We assume that you are already familiar with <code>numpy</code> and/or have completed the previous courses of the specialization. Let's get started!</p>
<h4 id="packages">1 - Packages</h4>
<p>Let's first import all the packages that you will need during this assignment. - <a href="www.numpy.org">numpy</a> is the fundamental package for scientific computing with Python. - <a target="_blank" rel="noopener" href="http://matplotlib.org">matplotlib</a> is a library to plot graphs in Python. - np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">get_ipython().run_line_magic(<span class="string">&#x27;matplotlib&#x27;</span>, <span class="string">&#x27;inline&#x27;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">5.0</span>, <span class="number">4.0</span>) set default size of plots</span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.interpolation&#x27;</span>] = <span class="string">&#x27;nearest&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.cmap&#x27;</span>] = <span class="string">&#x27;gray&#x27;</span></span><br><span class="line"></span><br><span class="line">get_ipython().run_line_magic(<span class="string">&#x27;load_ext&#x27;</span>, <span class="string">&#x27;autoreload&#x27;</span>)</span><br><span class="line">get_ipython().run_line_magic(<span class="string">&#x27;autoreload&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="outline-of-the-assignment">2 - Outline of the Assignment</h4>
<p>You will be implementing the building blocks of a convolutional neural network! Each function you will implement will have detailed instructions that will walk you through the steps needed:</p>
<ul>
<li>Convolution functions, including:
<ul>
<li>Zero Padding</li>
<li>Convolve window</li>
<li>Convolution forward</li>
<li>Convolution backward (optional)</li>
</ul></li>
<li>Pooling functions, including:
<ul>
<li>Pooling forward</li>
<li>Create mask</li>
<li>Distribute value</li>
<li>Pooling backward (optional)</li>
</ul></li>
</ul>
<p>This notebook will ask you to implement these functions from scratch in <code>numpy</code>. In the next notebook, you will use the TensorFlow equivalents of these functions to build the following model:</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/model.png" class="" title="Modle">
<p><strong>Note</strong> that for every forward function, there is its corresponding backward equivalent. Hence, at every step of your forward module you will store some parameters in a cache. These parameters are used to compute gradients during backpropagation.</p>
<h4 id="convolutional-neural-networks-1">3 - Convolutional Neural Networks</h4>
<p>Although programming frameworks make convolutions easy to use, they remain one of the hardest concepts to understand in Deep Learning. A convolution layer transforms an input volume into an output volume of different size, as shown below.</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_nn.png" class="" title="Conv NN">
<p>In this part, you will build every step of the convolution layer. You will first implement two helper functions: one for zero padding and the other for computing the convolution function itself.</p>
<h5 id="zero-padding">3.1 - Zero-Padding</h5>
<p>Zero-padding adds zeros around the border of an image:</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/PAD.png" class="" title="Zero-Padding Image (3 channels, RGB) with a padding of 2.">
<p>The main benefits of padding are the following:</p>
<ul>
<li><p>It allows you to use a CONV layer without necessarily shrinking the height and width of the volumes. This is important for building deeper networks, since otherwise the height/width would shrink as you go to deeper layers. An important special case is the &quot;same&quot; convolution, in which the height/width is exactly preserved after one layer.</p></li>
<li><p>It helps us keep more of the information at the border of an image. Without padding, very few values at the next layer would be affected by pixels as the edges of an image.</p></li>
</ul>
<p><strong>Exercise</strong>: Implement the following function, which pads all the images of a batch of examples X with zeros. <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html">Use np.pad</a>. Note if you want to pad the array &quot;a&quot; of shape <span class="math inline">\((5,5,5,5,5)\)</span> with <code>pad = 1</code> for the 2nd dimension, <code>pad = 3</code> for the 4th dimension and <code>pad = 0</code> for the rest, you would do:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.pad(a, ((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">3</span>,<span class="number">3</span>), (<span class="number">0</span>,<span class="number">0</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values = (..,..))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RADED FUNCTION: zero_pad</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_pad</span>(<span class="params">X, pad</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Pad with zeros all images of the dataset X. The padding is applied to the height and width of an image, </span></span><br><span class="line"><span class="string">    as illustrated in Figure 1.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    X -- python numpy array of shape (m, n_H, n_W, n_C) representing a batch of m images</span></span><br><span class="line"><span class="string">    pad -- integer, amount of padding around each image on vertical and horizontal dimensions</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    X_pad -- padded image of shape (m, n_H + 2*pad, n_W + 2*pad, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ##(≈ 1 line)</span></span><br><span class="line">    X_pad = np.pad(X, ((<span class="number">0</span>,<span class="number">0</span>),(pad,pad),(pad,pad),(<span class="number">0</span>,<span class="number">0</span>)), <span class="string">&#x27;constant&#x27;</span>)</span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X_pad</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="single-step-of-convolution">3.2 - Single step of convolution</h5>
<p>In this part, implement a single step of convolution, in which you apply the filter to a single position of the input. This will be used to build a convolutional unit, which:</p>
<ul>
<li>Takes an input volume</li>
<li>Applies a filter at every position of the input</li>
<li>Outputs another volume (usually of different size)</li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/Convolution_schematic.gif" class="" title="Convolution operation with a filter of 2x2 and a stride of 1 (stride &#x3D; amount you move the window each time you slide)">
<p>In a computer vision application, each value in the matrix on the left corresponds to a single pixel value, and we convolve a 3x3 filter with the image by multiplying its values element-wise with the original matrix, then summing them up and adding a bias. In this first step of the exercise, you will implement a single step of convolution, corresponding to applying a filter to just one of the positions to get a single real-valued output.</p>
<p>Later in this notebook, you'll apply this function to multiple positions of the input to implement the full convolutional operation.</p>
<p><strong>Exercise</strong>: Implement conv_single_step(). <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.sum.html">Hint</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: conv_single_step</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_single_step</span>(<span class="params">a_slice_prev, W, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Apply one filter defined by parameters W on a single slice (a_slice_prev) of the output activation </span></span><br><span class="line"><span class="string">    of the previous layer.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    a_slice_prev -- slice of input data of shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- Weight parameters contained in a window - matrix of shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    b -- Bias parameters contained in a window - matrix of shape (1, 1, 1)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    Z -- a scalar value, result of convolving the sliding window (W, b) on a slice x of the input data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">##START CODE HERE ##(≈ 2 lines of code)</span></span><br><span class="line">    Element-wise product between a_slice <span class="keyword">and</span> W. Do <span class="keyword">not</span> add the bias yet.</span><br><span class="line">    s = a_slice_prev * W</span><br><span class="line">    Sum over all entries of the volume s.</span><br><span class="line">    Z = np.sum(s)</span><br><span class="line">    Add bias b to Z. Cast b to a float() so that Z results <span class="keyword">in</span> a scalar value.</span><br><span class="line">    Z = Z + float(b)</span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Z</span><br></pre></td></tr></table></figure>
<h5 id="convolutional-neural-networks---forward-pass">3.3 - Convolutional Neural Networks - Forward pass</h5>
<p>In the forward pass, you will take many filters and convolve them on the input. Each 'convolution' gives you a 2D matrix output. You will then stack these outputs to get a 3D volume:</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_kiank.gif" class="" title="Conv Kiank">
<p><strong>Exercise</strong>: Implement the function below to convolve the filters W on an input activation A_prev. This function takes as input A_prev, the activations output by the previous layer (for a batch of m inputs), F filters/weights denoted by W, and a bias vector denoted by b, where each filter has its own (single) bias. Finally you also have access to the hyperparameters dictionary which contains the stride and the padding.</p>
<p><strong>Hint</strong>: 1. To select a 2x2 slice at the upper left corner of a matrix &quot;a_prev&quot; (shape (5,5,3)), you would do: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_slice_prev = a_prev[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>,:]</span><br></pre></td></tr></table></figure> This will be useful when you will define <code>a_slice_prev</code> below, using the <code>start/end</code> indexes you will define. 2. To define a_slice you will need to first define its corners <code>vert_start</code>, <code>vert_end</code>, <code>horiz_start</code> and <code>horiz_end</code>. This figure may be helpful for you to find how each of the corner can be defined using h, w, f and s in the code below.</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vert_horiz_kiank.png" class="" title="Definition of a slice using vertical and horizontal start&#x2F;end (with a 2x2 filter). This figure shows only a single channel">
<p><strong>Reminder</strong>: The formulas relating the output shape of the convolution to the input shape is: <span class="math display">\[ n_H = \lfloor \frac{n_{H_{prev}} - f + 2 \times pad}{stride} \rfloor +1 \]</span></p>
<p><span class="math display">\[ n_W = \lfloor \frac{n_{W_{prev}} - f + 2 \times pad}{stride} \rfloor +1 \]</span></p>
<p><span class="math display">\[ n_C = \text{number of filters used in the convolution}\]</span></p>
<p>For this exercise, we won't worry about vectorization, and will just implement everything with for-loops.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: conv_forward</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_forward</span>(<span class="params">A_prev, W, b, hparameters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the forward propagation for a convolution function</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    A_prev -- output activations of the previous layer, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- Weights, numpy array of shape (f, f, n_C_prev, n_C)</span></span><br><span class="line"><span class="string">    b -- Biases, numpy array of shape (1, 1, 1, n_C)</span></span><br><span class="line"><span class="string">    hparameters -- python dictionary containing &quot;stride&quot; and &quot;pad&quot;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    Z -- conv output, numpy array of shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- cache of values needed for the conv_backward() function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Retrieve dimensions from A_prev&#x27;s shape (≈1 line)  </span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from W&#x27;s shape (≈1 line)</span></span><br><span class="line">    (f, f, n_C_prev, n_C) = W.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve information from &quot;hparameters&quot; (≈2 lines)</span></span><br><span class="line">    stride = hparameters[<span class="string">&#x27;stride&#x27;</span>]</span><br><span class="line">    pad = hparameters[<span class="string">&#x27;pad&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute the dimensions of the CONV output volume using the formula given above. Hint: use int() to floor. (≈2 lines)</span></span><br><span class="line">    n_H = int((n_H_prev+<span class="number">2</span>*pad-f)/stride+<span class="number">1</span>)</span><br><span class="line">    n_W = int((n_W_prev+<span class="number">2</span>*pad-f)/stride+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize the output volume Z with zeros. (≈1 line)</span></span><br><span class="line">    Z = np.zeros((m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create A_prev_pad by padding A_prev</span></span><br><span class="line">    A_prev_pad = zero_pad(A_prev, pad)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                              <span class="comment"># loop over the batch of training examples</span></span><br><span class="line">        a_prev_pad = A_prev_pad[i,:]                <span class="comment"># Select ith training example&#x27;s padded activation</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                          <span class="comment"># loop over vertical axis of the output volume</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):                      <span class="comment"># loop over horizontal axis of the output volume</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):                  <span class="comment"># loop over channels (= #filters) of the output volume</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    <span class="comment"># Note: there is a stride, therefore it is not wise to assign vert_start a value of h and it is the same with horiz_start</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + f</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Use the corners to define the (3D) slice of a_prev_pad (See Hint above the cell). (≈1 line)</span></span><br><span class="line">                    a_slice_prev = a_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Convolve the (3D) slice with the correct filter W and bias b, to get back one output neuron. (≈1 line)</span></span><br><span class="line">                    Z[i, h, w, c] = np.sum(a_slice_prev * W[:, :, :, c]) + float(b[:, :, :, c])</span><br><span class="line">                    Z[i, h, w, c] = conv_single_step(a_slice_prev, W[:, :, :, c], b[:, :, :, c])</span><br><span class="line">                                        </span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Making sure your output shape is correct</span></span><br><span class="line">    <span class="keyword">assert</span>(Z.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Save information in &quot;cache&quot; for the backprop</span></span><br><span class="line">    cache = (A_prev, W, b, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z, cache</span><br></pre></td></tr></table></figure>
<p>Finally, CONV layer should also contain an activation, in which case we would add the following line of code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convolve the window to get back one output neuron</span></span><br><span class="line">Z[i, h, w, c] = ...</span><br><span class="line"><span class="comment"># Apply activation</span></span><br><span class="line">A[i, h, w, c] = activation(Z[i, h, w, c])</span><br></pre></td></tr></table></figure>
<p>You don't need to do it here.</p>
<h4 id="pooling-layer">4 - Pooling layer</h4>
<p>The pooling (POOL) layer reduces the height and width of the input. It helps reduce computation, as well as helps make feature detectors more invariant to its position in the input. The two types of pooling layers are:</p>
<ul>
<li><p>Max-pooling layer: slides an (<span class="math inline">\(f, f\)</span>) window over the input and stores the max value of the window in the output.</p></li>
<li><p>Average-pooling layer: slides an (<span class="math inline">\(f, f\)</span>) window over the input and stores the average value of the window in the output.</p></li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/max_pool1.png" class="" title="Max Pooling">
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/a_pool.png" class="" title="Average Pooling">
<p>These pooling layers have no parameters for backpropagation to train. However, they have hyperparameters such as the window size <span class="math inline">\(f\)</span>. This specifies the height and width of the fxf window you would compute a max or average over.</p>
<h5 id="forward-pooling">4.1 - Forward Pooling</h5>
<p>Now, you are going to implement MAX-POOL and AVG-POOL, in the same function.</p>
<p><strong>Exercise</strong>: Implement the forward pass of the pooling layer. Follow the hints in the comments below.</p>
<p><strong>Reminder</strong>: As there's no padding, the formulas binding the output shape of the pooling to the input shape is:</p>
<p><span class="math display">\[ n_H = \lfloor \frac{n_{H_{prev}} - f}{stride} \rfloor +1 \]</span></p>
<p><span class="math display">\[ n_W = \lfloor \frac{n_{W_{prev}} - f}{stride} \rfloor +1 \]</span></p>
<p><span class="math display">\[ n_C = n_{C_{prev}}\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GRADED FUNCTION: pool_forward</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool_forward</span>(<span class="params">A_prev, hparameters, mode = <span class="string">&quot;max&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the forward pass of the pooling layer</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    A_prev -- Input data, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    hparameters -- python dictionary containing &quot;f&quot; and &quot;stride&quot;</span></span><br><span class="line"><span class="string">    mode -- the pooling mode you would like to use, defined as a string (&quot;max&quot; or &quot;average&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    A -- output of the pool layer, a numpy array of shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- cache used in the backward pass of the pooling layer, contains the input and hparameters </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from the input shape</span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve hyperparameters from &quot;hparameters&quot;</span></span><br><span class="line">    f = hparameters[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Define the dimensions of the output</span></span><br><span class="line">    n_H = int(<span class="number">1</span> + (n_H_prev - f) / stride)</span><br><span class="line">    n_W = int(<span class="number">1</span> + (n_W_prev - f) / stride)</span><br><span class="line">    n_C = n_C_prev</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize output matrix A</span></span><br><span class="line">    A = np.zeros((m, n_H, n_W, n_C))              </span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ###</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                          <span class="comment"># loop over the training examples</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                    <span class="comment"># loop on the vertical axis of the output volume</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):                <span class="comment"># loop on the horizontal axis of the output volume</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range (n_C):           <span class="comment"># loop over the channels of the output volume</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    vert_start = h*stride</span><br><span class="line">                    vert_end = vert_start+f</span><br><span class="line">                    horiz_start = w*stride</span><br><span class="line">                    horiz_end = horiz_start+f</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Use the corners to define the current slice on the ith training example of A_prev, channel c. (≈1 line)</span></span><br><span class="line">                    a_prev_slice = A_prev[i, vert_start:vert_end, horiz_start:horiz_end, c]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Compute the pooling operation on the slice. Use an if statment to differentiate the modes. Use np.max/np.mean.</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">                        A[i, h, w, c] = np.max(a_prev_slice)</span><br><span class="line">                    <span class="keyword">elif</span> mode == <span class="string">&quot;average&quot;</span>:</span><br><span class="line">                        A[i, h, w, c] = np.sum(a_prev_slice)/(f*f)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Store the input and hparameters in &quot;cache&quot; for pool_backward()</span></span><br><span class="line">    cache = (A_prev, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Making sure your output shape is correct</span></span><br><span class="line">    <span class="keyword">assert</span>(A.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br></pre></td></tr></table></figure>
<p>Congratulations! You have now implemented the forward passes of all the layers of a convolutional network.</p>
<p>The remainer of this notebook is optional, and will not be graded.</p>
<h4 id="backpropagation-in-convolutional-neural-networks-optional-ungraded">5 - Backpropagation in convolutional neural networks (OPTIONAL / UNGRADED)</h4>
<p>In modern deep learning frameworks, you only have to implement the forward pass, and the framework takes care of the backward pass, so most deep learning engineers don't need to bother with the details of the backward pass. The backward pass for convolutional networks is complicated. If you wish however, you can work through this optional portion of the notebook to get a sense of what backprop in a convolutional network looks like.</p>
<p>When in an earlier course you implemented a simple (fully connected) neural network, you used backpropagation to compute the derivatives with respect to the cost to update the parameters. Similarly, in convolutional neural networks you can to calculate the derivatives with respect to the cost in order to update the parameters. The backprop equations are not trivial and we did not derive them in lecture, but we briefly presented them below.</p>
<h5 id="convolutional-layer-backward-pass">5.1 - Convolutional layer backward pass</h5>
<p>Let's start by implementing the backward pass for a CONV layer.</p>
<h6 id="computing-da">5.1.1 - Computing dA</h6>
<p>This is the formula for computing <span class="math inline">\(dA\)</span> with respect to the cost for a certain filter <span class="math inline">\(W_c\)</span> and a given training example:</p>
<p><span class="math display">\[ dA += \sum _{h=0} ^{n_H} \sum_{w=0} ^{n_W} W_c \times dZ_{hw} \]</span></p>
<p>Where <span class="math inline">\(W_c\)</span> is a filter and <span class="math inline">\(dZ_{hw}\)</span> is a scalar corresponding to the gradient of the cost with respect to the output of the conv layer <span class="math inline">\(Z\)</span> at the <span class="math inline">\(h^{th}\)</span> row and wth column (corresponding to the dot product taken at the ith stride left and jth stride down). Note that at each time, we multiply the the same filter <span class="math inline">\(W_c\)</span> by a different dZ when updating <span class="math inline">\(dA\)</span>. We do so mainly because when computing the forward propagation, each filter is dotted and summed by a different a_slice. Therefore when computing the backprop for <span class="math inline">\(dA\)</span>, we are just adding the gradients of all the a_slices.</p>
<p>In code, inside the appropriate for-loops, this formula translates into:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += W[:,:,:,c] * dZ[i, h, w, c]</span><br></pre></td></tr></table></figure>
<h5 id="computing-dw">5.1.2 - Computing dW</h5>
<p>This is the formula for computing <span class="math inline">\(dW_c\)</span> (<span class="math inline">\(dW_c\)</span> is the derivative of one filter) with respect to the loss:</p>
<p><span class="math display">\[ dW_c  += \sum _{h=0} ^{n_H} \sum_{w=0} ^ {n_W} a_{slice} \times dZ_{hw}  \]</span></p>
<p>Where $ a_{slice} $ corresponds to the slice which was used to generate the acitivation $ Z_{ij} $. Hence, this ends up giving us the gradient for $ W $ with respect to that slice. Since it is the same $ W $, we will just add up all such gradients to get $ dW $.</p>
<p>In code, inside the appropriate for-loops, this formula translates into: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dW[:,:,:,c] += a_slice * dZ[i, h, w, c]</span><br></pre></td></tr></table></figure></p>
<h6 id="computing-db">5.1.3 - Computing db</h6>
<p>This is the formula for computing <span class="math inline">\(db\)</span> with respect to the cost for a certain filter <span class="math inline">\(W_c\)</span>:</p>
<p><span class="math display">\[ db = \sum_h \sum_w dZ_{hw} \]</span></p>
<p>As you have previously seen in basic neural networks, db is computed by summing <span class="math inline">\(dZ\)</span>. In this case, you are just summing over all the gradients of the conv output (Z) with respect to the cost.</p>
<p>In code, inside the appropriate for-loops, this formula translates into: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db[:,:,:,c] += dZ[i, h, w, c]</span><br></pre></td></tr></table></figure></p>
<p><strong>Exercise</strong>: Implement the <code>conv_backward</code> function below. You should sum over all the training examples, filters, heights, and widths. You should then compute the derivatives using formulas 1, 2 and 3 above.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_backward</span>(<span class="params">dZ, cache</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implement the backward propagation for a convolution function</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    dZ -- gradient of the cost with respect to the output of the conv layer (Z), numpy array of shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- cache of values needed for the conv_backward(), output of conv_forward()</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    dA_prev -- gradient of the cost with respect to the input of the conv layer (A_prev),</span></span><br><span class="line"><span class="string">               numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    dW -- gradient of the cost with respect to the weights of the conv layer (W)</span></span><br><span class="line"><span class="string">          numpy array of shape (f, f, n_C_prev, n_C)</span></span><br><span class="line"><span class="string">    db -- gradient of the cost with respect to the biases of the conv layer (b)</span></span><br><span class="line"><span class="string">          numpy array of shape (1, 1, 1, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Retrieve information from &quot;cache&quot;</span></span><br><span class="line">    (A_prev, W, b, hparameters) = cache</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from A_prev&#x27;s shape</span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from W&#x27;s shape</span></span><br><span class="line">    (f, f, n_C_prev, n_C) = W.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve information from &quot;hparameters&quot;</span></span><br><span class="line">    stride = hparameters[<span class="string">&#x27;stride&#x27;</span>]</span><br><span class="line">    pad = hparameters[<span class="string">&#x27;pad&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from dZ&#x27;s shape</span></span><br><span class="line">    (m, n_H, n_W, n_C) = dZ.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize dA_prev, dW, db with the correct shapes</span></span><br><span class="line">    dA_prev = np.zeros((m, n_H_prev, n_W_prev, n_C_prev))                           </span><br><span class="line">    dW = np.zeros((f, f, n_C_prev, n_C))</span><br><span class="line">    db = np.zeros((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n_C))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pad A_prev and dA_prev</span></span><br><span class="line">    A_prev_pad = zero_pad(A_prev, pad)</span><br><span class="line">    dA_prev_pad = zero_pad(dA_prev, pad)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                      <span class="comment"># loop over the training examples</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># select ith training example from A_prev_pad and dA_prev_pad</span></span><br><span class="line">        a_prev_pad = A_prev_pad[i, :]</span><br><span class="line">        da_prev_pad = dA_prev_pad[i, :]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                   <span class="comment"># loop over vertical axis of the output volume</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):               <span class="comment"># loop over horizontal axis of the output volume</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):           <span class="comment"># loop over the channels of the output volume</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot;</span></span><br><span class="line">                    vert_start = h*stride</span><br><span class="line">                    vert_end = vert_start+f</span><br><span class="line">                    horiz_start = w*stride</span><br><span class="line">                    horiz_end = horiz_start+f</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Use the corners to define the slice from a_prev_pad</span></span><br><span class="line">                    a_slice = a_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Update gradients for the window and the filter&#x27;s parameters using the code formulas given above</span></span><br><span class="line">                    da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += W[:,:,:,c] * dZ[i, h, w, c]</span><br><span class="line">                    dW[:,:,:,c] += a_slice * dZ[i, h, w, c]</span><br><span class="line">                    db[:,:,:,c] += dZ[i, h, w, c]</span><br><span class="line">                    </span><br><span class="line">        <span class="comment"># Set the ith training example&#x27;s dA_prev to the unpaded da_prev_pad (Hint: use X[pad:-pad, pad:-pad, :])</span></span><br><span class="line">        dA_prev[i, :, :, :] = dA_prev_pad[i, pad:-pad, pad:-pad, :]</span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Making sure your output shape is correct</span></span><br><span class="line">    <span class="keyword">assert</span>(dA_prev.shape == (m, n_H_prev, n_W_prev, n_C_prev))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dA_prev, dW, db</span><br></pre></td></tr></table></figure>
<h5 id="pooling-layer---backward-pass">5.2 Pooling layer - backward pass</h5>
<p>Next, let's implement the backward pass for the pooling layer, starting with the MAX-POOL layer. Even though a pooling layer has no parameters for backprop to update, you still need to backpropagation the gradient through the pooling layer in order to compute gradients for layers that came before the pooling layer.</p>
<h6 id="max-pooling---backward-pass">5.2.1 Max pooling - backward pass</h6>
<p>Before jumping into the backpropagation of the pooling layer, you are going to build a helper function called <code>create_mask_from_window()</code> which does the following:</p>
<p><span class="math display">\[ X = \begin{bmatrix}
1 &amp;&amp; 3 \\
4 &amp;&amp; 2
\end{bmatrix} \quad \rightarrow  \quad M =\begin{bmatrix}
0 &amp;&amp; 0 \\
1 &amp;&amp; 0
\end{bmatrix}\]</span></p>
<p>As you can see, this function creates a &quot;mask&quot; matrix which keeps track of where the maximum of the matrix is. True (1) indicates the position of the maximum in X, the other entries are False (0). You'll see later that the backward pass for average pooling will be similar to this but using a different mask.</p>
<p><strong>Exercise</strong>: Implement <code>create_mask_from_window()</code>. This function will be helpful for pooling backward. Hints: - <a href="">np.max()</a> may be helpful. It computes the maximum of an array. - If you have a matrix X and a scalar x: <code>A = (X == x)</code> will return a matrix A of the same size as X such that: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[i,j] &#x3D; True if X[i,j] &#x3D; x</span><br><span class="line">A[i,j] &#x3D; False if X[i,j] !&#x3D; x</span><br></pre></td></tr></table></figure> - Here, you don't need to consider cases where there are several maxima in a matrix.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mask_from_window</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Creates a mask from an input matrix x, to identify the max entry of x.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    x -- Array of shape (f, f)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    mask -- Array of the same shape as window, contains a True at the position corresponding to the max entry of x.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ##(≈1 line)</span></span><br><span class="line">    mask = (x == np.max(x))</span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mask</span><br></pre></td></tr></table></figure>
<p>Why do we keep track of the position of the max? It's because this is the input value that ultimately influenced the output, and therefore the cost. Backprop is computing gradients with respect to the cost, so anything that influences the ultimate cost should have a non-zero gradient. So, backprop will &quot;propagate&quot; the gradient back to this particular input value that had influenced the cost.</p>
<h6 id="average-pooling---backward-pass">5.2.2 - Average pooling - backward pass</h6>
<p>In max pooling, for each input window, all the &quot;influence&quot; on the output came from a single input value--the max. In average pooling, every element of the input window has equal influence on the output. So to implement backprop, you will now implement a helper function that reflects this.</p>
<p>For example if we did average pooling in the forward pass using a 2x2 filter, then the mask you'll use for the backward pass will look like: <span class="math display">\[ dZ = 1 \quad \rightarrow  \quad dZ =\begin{bmatrix}
1/4 &amp;&amp; 1/4 \\
1/4 &amp;&amp; 1/4
\end{bmatrix}\]</span></p>
<p>This implies that each position in the <span class="math inline">\(dZ\)</span> matrix contributes equally to output because in the forward pass, we took an average.</p>
<p><strong>Exercise</strong>: Implement the function below to equally distribute a value dz through a matrix of dimension shape. <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ones.html">Hint</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distribute_value</span>(<span class="params">dz, shape</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Distributes the input value in the matrix of dimension shape</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    dz -- input scalar</span></span><br><span class="line"><span class="string">    shape -- the shape (n_H, n_W) of the output matrix for which we want to distribute the value of dz</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    a -- Array of size (n_H, n_W) for which we distributed the value of dz</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Retrieve dimensions from shape (≈1 line)</span></span><br><span class="line">    (n_H, n_W) = shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute the value to distribute on the matrix (≈1 line)</span></span><br><span class="line">    average = n_H * n_W</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a matrix where every entry is the &quot;average&quot; value (≈1 line)</span></span><br><span class="line">    a = np.ones(shape) * dz / average</span><br><span class="line">    <span class="comment">##END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h6 id="putting-it-together-pooling-backward">5.2.3 Putting it together: Pooling backward</h6>
<p>You now have everything you need to compute backward propagation on a pooling layer.</p>
<p><strong>Exercise</strong>: Implement the <code>pool_backward</code> function in both modes (<code>&quot;max&quot;</code> and <code>&quot;average&quot;</code>). You will once again use 4 for-loops (iterating over training examples, height, width, and channels). You should use an <code>if/elif</code> statement to see if the mode is equal to <code>'max'</code> or <code>'average'</code>. If it is equal to 'average' you should use the <code>distribute_value()</code> function you implemented above to create a matrix of the same shape as <code>a_slice</code>. Otherwise, the mode is equal to '<code>max</code>', and you will create a mask with <code>create_mask_from_window()</code> and multiply it by the corresponding value of dZ.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool_backward</span>(<span class="params">dA, cache, mode = <span class="string">&quot;max&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the backward pass of the pooling layer</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    dA -- gradient of cost with respect to the output of the pooling layer, same shape as A</span></span><br><span class="line"><span class="string">    cache -- cache output from the forward pass of the pooling layer, contains the layer&#x27;s input and hparameters </span></span><br><span class="line"><span class="string">    mode -- the pooling mode you would like to use, defined as a string (&quot;max&quot; or &quot;average&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    dA_prev -- gradient of cost with respect to the input of the pooling layer, same shape as A_prev</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##START CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve information from cache (≈1 line)</span></span><br><span class="line">    (A_prev, hparameters) = cache</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve hyperparameters from &quot;hparameters&quot; (≈2 lines)</span></span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    f = hparameters[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve dimensions from A_prev&#x27;s shape and dA&#x27;s shape (≈2 lines)</span></span><br><span class="line">    m, n_H_prev, n_W_prev, n_C_prev = A_prev.shape</span><br><span class="line">    m, n_H, n_W, n_C = dA.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize dA_prev with zeros (≈1 line)</span></span><br><span class="line">    dA_prev = np.zeros(A_prev.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                       <span class="comment"># loop over the training examples</span></span><br><span class="line">        <span class="comment">#select training example from A_prev (≈1 line)</span></span><br><span class="line">        a_prev = A_prev[i,:]</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                 <span class="comment">#  loop on the vertical axis</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):             <span class="comment">#  loop on the horizontal axis</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):         <span class="comment">#  loop over the channels (depth)</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + f </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Compute the backward propagation in both modes.</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">                        <span class="comment"># Use the corners and &quot;c&quot; to define the current slice from a_prev (≈1 line)</span></span><br><span class="line">                        a_prev_slice = a_prev[vert_start:vert_end,horiz_start:horiz_end,c]</span><br><span class="line">                        <span class="comment"># Create the mask from a_prev_slice (≈1 line)</span></span><br><span class="line">                        mask = create_mask_from_window(a_prev_slice)</span><br><span class="line">                        <span class="comment"># Set dA_prev to be dA_prev + (the mask multiplied by the correct entry of dA) (≈1 line)</span></span><br><span class="line">                        dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += mask * dA[i,h,w,c]</span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">elif</span> mode == <span class="string">&quot;average&quot;</span>:</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># Get the value a from dA (≈1 line)</span></span><br><span class="line">                        da = dA[i, h, w , c]</span><br><span class="line">                        <span class="comment"># Define the shape of the filter as fxf (≈1 line)</span></span><br><span class="line">                        shape = (f,f)</span><br><span class="line">                        <span class="comment"># Distribute it to get the correct slice of dA_prev. i.e. Add the distributed value of da. (≈1 line)</span></span><br><span class="line">                        dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += distribute_value(da, shape)</span><br><span class="line">                        </span><br><span class="line">    <span class="comment">##END CODE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Making sure your output shape is correct</span></span><br><span class="line">    <span class="keyword">assert</span>(dA_prev.shape == A_prev.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dA_prev</span><br></pre></td></tr></table></figure>
<h5 id="congratulations">Congratulations !</h5>
<p>Congratulation on completing this assignment. You now understand how convolutional neural networks work. You have implemented all the building blocks of a neural network. In the next assignment you will implement a ConvNet using TensorFlow.</p>
<h3 id="convolutional-neural-networks-application">Convolutional Neural Networks: Application</h3>
<p>Welcome to Course 4's second assignment! In this notebook, you will:</p>
<ul>
<li>Implement helper functions that you will use when implementing a TensorFlow model</li>
<li>Implement a fully functioning ConvNet using TensorFlow</li>
</ul>
<p><strong>After this assignment you will be able to:</strong></p>
<ul>
<li>Build and train a ConvNet in TensorFlow for a classification problem</li>
</ul>
<p>We assume here that you are already familiar with TensorFlow. If you are not, please refer the <em>TensorFlow Tutorial</em> of the third week of Course 2 (&quot;<em>Improving deep neural networks</em>&quot;).</p>
<h4 id="tensorflow-model">1 - TensorFlow model</h4>
<p>In the previous assignment, you built helper functions using numpy to understand the mechanics behind convolutional neural networks. Most practical applications of deep learning today are built using programming frameworks, which have many built-in functions you can simply call.</p>
<p>As usual, we will start by loading in the packages.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</span><br><span class="line"><span class="keyword">from</span> cnn_utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">get_ipython().magic(<span class="string">&#x27;matplotlib inline&#x27;</span>)</span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Run the next cell to load the &quot;SIGNS&quot; dataset you are going to use.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Loading the data (signs)</span></span><br><span class="line">X_train_orig, Y_train_orig, X_test_orig, Y_test_orig, classes = load_dataset()</span><br></pre></td></tr></table></figure>
<p>As a reminder, the SIGNS dataset is a collection of 6 signs representing numbers from 0 to 5.</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/SIGNS.png" class="">
<p>The next cell will show you an example of a labelled image in the dataset. Feel free to change the value of <code>index</code> below and re-run to see different examples.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Example of a picture</span></span><br><span class="line">index = <span class="number">6</span></span><br><span class="line">plt.imshow(X_train_orig[index])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;y = &quot;</span> + str(np.squeeze(Y_train_orig[:, index])))</span><br></pre></td></tr></table></figure>
<p>In Course 2, you had built a fully-connected network for this dataset. But since this is an image dataset, it is more natural to apply a ConvNet to it.</p>
<p>To get started, let's examine the shapes of your data.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">X_train = X_train_orig/<span class="number">255.</span></span><br><span class="line">X_test = X_test_orig/<span class="number">255.</span></span><br><span class="line">Y_train = convert_to_one_hot(Y_train_orig, <span class="number">6</span>).T</span><br><span class="line">Y_test = convert_to_one_hot(Y_test_orig, <span class="number">6</span>).T</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;number of training examples = &quot;</span> + str(X_train.shape[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;number of test examples = &quot;</span> + str(X_test.shape[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;X_train shape: &quot;</span> + str(X_train.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;Y_train shape: &quot;</span> + str(Y_train.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;X_test shape: &quot;</span> + str(X_test.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;Y_test shape: &quot;</span> + str(Y_test.shape))</span><br><span class="line">conv_layers = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="create-placeholders">1.1 - Create placeholders</h5>
<p>TensorFlow requires that you create placeholders for the input data that will be fed into the model when running the session.</p>
<p><strong>Exercise</strong>: Implement the function below to create placeholders for the input image X and the output Y. You should not define the number of training examples for the moment. To do so, you could use &quot;None&quot; as the batch size, it will give you the flexibility to choose it later. Hence X should be of dimension <strong>[None, n_H0, n_W0, n_C0]</strong> and Y should be of dimension <strong>[None, n_y]</strong>. <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/placeholder">Hint</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#GRADED FUNCTION: create_placeholders</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_placeholders</span>(<span class="params">n_H0, n_W0, n_C0, n_y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Creates the placeholders for the tensorflow session.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    n_H0 -- scalar, height of an input image</span></span><br><span class="line"><span class="string">    n_W0 -- scalar, width of an input image</span></span><br><span class="line"><span class="string">    n_C0 -- scalar, number of channels of the input</span></span><br><span class="line"><span class="string">    n_y -- scalar, number of classes</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    X -- placeholder for the data input, of shape [None, n_H0, n_W0, n_C0] and dtype &quot;float&quot;</span></span><br><span class="line"><span class="string">    Y -- placeholder for the input labels, of shape [None, n_y] and dtype &quot;float&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈2 lines)</span></span><br><span class="line">    X = tf.placeholder(shape = [<span class="literal">None</span>,n_H0, n_W0, n_C0], dtype = <span class="string">&quot;float32&quot;</span>, name = <span class="string">&quot;X&quot;</span>)</span><br><span class="line">    Y = tf.placeholder(shape = [<span class="literal">None</span>, n_y] , dtype = <span class="string">&quot;float32&quot;</span>, name = <span class="string">&quot;Y&quot;</span>)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br></pre></td></tr></table></figure>
<h5 id="initialize-parameters">1.2 - Initialize parameters</h5>
<p>You will initialize weights/filters <span class="math inline">\(W1\)</span> and <span class="math inline">\(W2\)</span> using <code>tf.contrib.layers.xavier_initializer(seed = 0)</code>. You don't need to worry about bias variables as you will soon see that TensorFlow functions take care of the bias. Note also that you will only initialize the weights/filters for the conv2d functions. TensorFlow initializes the layers for the fully connected part automatically. We will talk more about that later in this assignment.</p>
<p><strong>Exercise:</strong> Implement initialize_parameters(). The dimensions for each group of filters are provided below. Reminder - to initialize a parameter <span class="math inline">\(W\)</span> of shape [1,2,3,4] in Tensorflow, use:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = tf.get_variable(<span class="string">&quot;W&quot;</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], initializer = ...)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/get_variable">More Info</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#GRADED FUNCTION: initialize_parameters</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Initializes weight parameters to build a neural network with tensorflow. The shapes are:</span></span><br><span class="line"><span class="string">                        W1 : [4, 4, 3, 8]</span></span><br><span class="line"><span class="string">                        W2 : [2, 2, 8, 16]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    parameters -- a dictionary of tensors containing W1, W2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    tf.set_random_seed(<span class="number">1</span>) <span class="comment"># so that your &quot;random&quot; numbers match ours</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">### START CODE HERE ### (approx. 2 lines of code)</span></span><br><span class="line">    W1 = tf.get_variable(<span class="string">&quot;W1&quot;</span>, [<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">0</span>))</span><br><span class="line">    W2 = tf.get_variable(<span class="string">&quot;W2&quot;</span>, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">16</span>], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">0</span>))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1,</span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess_test:</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    sess_test.run(init)</span><br><span class="line">    print(<span class="string">&quot;W1 = &quot;</span> + str(parameters[<span class="string">&quot;W1&quot;</span>].eval()[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">&quot;W2 = &quot;</span> + str(parameters[<span class="string">&quot;W2&quot;</span>].eval()[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h4 id="forward-propagation">2 - Forward propagation</h4>
<p>In TensorFlow, there are built-in functions that carry out the convolution steps for you.</p>
<ul>
<li><p><strong>tf.nn.conv2d(X,W1, strides = [1,s,s,1], padding = 'SAME'):</strong> given an input <span class="math inline">\(X\)</span> and a group of filters <span class="math inline">\(W1\)</span>, this function convolves <span class="math inline">\(W1\)</span>'s filters on X. The third input ([1,f,f,1]) represents the strides for each dimension of the input (m, n_H_prev, n_W_prev, n_C_prev). You can read the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d">here</a></p></li>
<li><p><strong>tf.nn.max_pool(A, ksize = [1,f,f,1], strides = [1,s,s,1], padding = 'SAME'):</strong> given an input A, this function uses a window of size (f, f) and strides of size (s, s) to carry out max pooling over each window. You can read the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool">here</a></p></li>
<li><p><strong>tf.nn.relu(Z1):</strong> computes the elementwise ReLU of Z1 (which can be any shape). You can read the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/nn/relu">here.</a></p></li>
<li><p><strong>tf.contrib.layers.flatten(P)</strong>: given an input P, this function flattens each example into a 1D vector it while maintaining the batch-size. It returns a flattened tensor with shape [batch_size, k]. You can read the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/contrib/layers/flatten">here.</a></p></li>
<li><p><strong>tf.contrib.layers.fully_connected(F, num_outputs):</strong> given a the flattened input F, it returns the output computed using a fully connected layer. You can read the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/contrib/layers/fully_connected">here.</a></p></li>
</ul>
<p>In the last function above (<code>tf.contrib.layers.fully_connected</code>), the fully connected layer automatically initializes weights in the graph and keeps on training them as you train the model. Hence, you did not need to initialize those weights when initializing the parameters.</p>
<p><strong>Exercise</strong>:</p>
<p>Implement the <code>forward_propagation</code> function below to build the following model: <code>CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</code>. You should use the functions above.</p>
<p>In detail, we will use the following parameters for all the steps: - Conv2D: stride 1, padding is &quot;SAME&quot; - ReLU - Max pool: Use an 8 by 8 filter size and an 8 by 8 stride, padding is &quot;SAME&quot; - Conv2D: stride 1, padding is &quot;SAME&quot; - ReLU - Max pool: Use a 4 by 4 filter size and a 4 by 4 stride, padding is &quot;SAME&quot; - Flatten the previous output. - FULLYCONNECTED (FC) layer: Apply a fully connected layer without an non-linear activation function. Do not call the softmax here. This will result in 6 neurons in the output layer, which then get passed later to a softmax. In TensorFlow, the softmax and cost function are lumped together into a single function, which you'll call in a different function when computing the cost.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: forward_propagation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span>(<span class="params">X, parameters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements the forward propagation for the model:</span></span><br><span class="line"><span class="string">    CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X -- input dataset placeholder, of shape (input size, number of examples)</span></span><br><span class="line"><span class="string">    parameters -- python dictionary containing your parameters &quot;W1&quot;, &quot;W2&quot;</span></span><br><span class="line"><span class="string">                  the shapes are given in initialize_parameters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    Z3 -- the output of the last LINEAR unit</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve the parameters from the dictionary &quot;parameters&quot; </span></span><br><span class="line">    W1 = parameters[<span class="string">&#x27;W1&#x27;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># CONV2D: stride of 1, padding &#x27;SAME&#x27;</span></span><br><span class="line">    Z1 = tf.nn.conv2d(X,W1, strides = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line">    <span class="comment"># RELU</span></span><br><span class="line">    A1 = tf.nn.relu(Z1)</span><br><span class="line">    <span class="comment"># MAXPOOL: window 8x8, sride 8, padding &#x27;SAME&#x27;</span></span><br><span class="line">    P1 = tf.nn.max_pool(A1, ksize = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>], strides = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>], padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line">    <span class="comment"># CONV2D: filters W2, stride 1, padding &#x27;SAME&#x27;</span></span><br><span class="line">    Z2 = tf.nn.conv2d(P1,W2, strides = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line">    <span class="comment"># RELU</span></span><br><span class="line">    A2 = tf.nn.relu(Z2)</span><br><span class="line">    <span class="comment"># MAXPOOL: window 4x4, stride 4, padding &#x27;SAME&#x27;</span></span><br><span class="line">    P2 = tf.nn.max_pool(A2, ksize = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>], strides = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>],padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line">    <span class="comment"># FLATTEN</span></span><br><span class="line">    P2 = tf.contrib.layers.flatten(P2)</span><br><span class="line">    <span class="comment"># FULLY-CONNECTED without non-linear activation function (not not call softmax).</span></span><br><span class="line">    <span class="comment"># 6 neurons in output layer. Hint: one of the arguments should be &quot;activation_fn=None&quot; </span></span><br><span class="line">    Z3 = tf.contrib.layers.fully_connected(P2, <span class="number">6</span>, activation_fn=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Z3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tf.reset_default_graph()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X, Y = create_placeholders(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init)</span><br><span class="line">    a = sess.run(Z3, &#123;X: np.random.randn(<span class="number">2</span>,<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), Y: np.random.randn(<span class="number">2</span>,<span class="number">6</span>)&#125;)</span><br><span class="line">    print(<span class="string">&quot;Z3 = &quot;</span> + str(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="compute-cost">3 - Compute cost</h4>
<p>Implement the compute cost function below. You might find these two functions helpful:</p>
<ul>
<li><strong>tf.nn.softmax_cross_entropy_with_logits(logits = Z3, labels = Y):</strong> computes the softmax entropy loss. This function both computes the softmax activation function as well as the resulting loss. You can check the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits">here.</a></li>
<li><strong>tf.reduce_mean:</strong> computes the mean of elements across dimensions of a tensor. Use this to sum the losses over all the examples to get the overall cost. You can check the full documentation <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/reduce_mean">here.</a></li>
</ul>
<p><strong>Exercise</strong>: Compute the cost below using the function above.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GRADED FUNCTION: compute_cost </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span>(<span class="params">Z3, Y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes the cost</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    Z3 -- output of forward propagation (output of the last LINEAR unit), of shape (6, number of examples)</span></span><br><span class="line"><span class="string">    Y -- &quot;true&quot; labels vector placeholder, same shape as Z3</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    cost - Tensor of the cost function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line of code)</span></span><br><span class="line">    cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = Z3, labels = Y))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    X, Y = create_placeholders(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init)</span><br><span class="line">    a = sess.run(cost, &#123;X: np.random.randn(<span class="number">4</span>,<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), Y: np.random.randn(<span class="number">4</span>,<span class="number">6</span>)&#125;)</span><br><span class="line">    print(<span class="string">&quot;cost = &quot;</span> + str(a))</span><br></pre></td></tr></table></figure>
<h4 id="model">4 Model</h4>
<p>Finally you will merge the helper functions you implemented above to build a model. You will train it on the SIGNS dataset.</p>
<p>You have implemented <code>random_mini_batches()</code> in the Optimization programming assignment of course 2. Remember that this function returns a list of mini-batches.</p>
<p><strong>Exercise</strong>: Complete the function below.</p>
<p>The model below should:</p>
<ul>
<li>create placeholders</li>
<li>initialize parameters</li>
<li>forward propagate</li>
<li>compute the cost</li>
<li>create an optimizer</li>
</ul>
<p>Finally you will create a session and run a for loop for num_epochs, get the mini-batches, and then for each mini-batch you will optimize the function. <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/global_variables_initializer">Hint for initializing the variables</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#GRADED FUNCTION: model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">X_train, Y_train, X_test, Y_test, learning_rate = <span class="number">0.009</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">          num_epochs = <span class="number">100</span>, minibatch_size = <span class="number">64</span>, print_cost = True</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implements a three-layer ConvNet in Tensorflow:</span></span><br><span class="line"><span class="string">    CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X_train -- training set, of shape (None, 64, 64, 3)</span></span><br><span class="line"><span class="string">    Y_train -- test set, of shape (None, n_y = 6)</span></span><br><span class="line"><span class="string">    X_test -- training set, of shape (None, 64, 64, 3)</span></span><br><span class="line"><span class="string">    Y_test -- test set, of shape (None, n_y = 6)</span></span><br><span class="line"><span class="string">    learning_rate -- learning rate of the optimization</span></span><br><span class="line"><span class="string">    num_epochs -- number of epochs of the optimization loop</span></span><br><span class="line"><span class="string">    minibatch_size -- size of a minibatch</span></span><br><span class="line"><span class="string">    print_cost -- True to print the cost every 100 epochs</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    train_accuracy -- real number, accuracy on the train set (X_train)</span></span><br><span class="line"><span class="string">    test_accuracy -- real number, testing accuracy on the test set (X_test)</span></span><br><span class="line"><span class="string">    parameters -- parameters learnt by the model. They can then be used to predict.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    ops.reset_default_graph()                         <span class="comment"># to be able to rerun the model without overwriting tf variables</span></span><br><span class="line">    tf.set_random_seed(<span class="number">1</span>)                             <span class="comment"># to keep results consistent (tensorflow seed)</span></span><br><span class="line">    seed = <span class="number">3</span>                                          <span class="comment"># to keep results consistent (numpy seed)</span></span><br><span class="line">    (m, n_H0, n_W0, n_C0) = X_train.shape             </span><br><span class="line">    n_y = Y_train.shape[<span class="number">1</span>]                            </span><br><span class="line">    costs = []                                        <span class="comment"># To keep track of the cost</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create Placeholders of the correct shape</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    X, Y = create_placeholders(n_H0, n_W0, n_C0, n_y)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize parameters</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Forward propagation: Build the forward propagation in the tensorflow graph</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Cost function: Add cost function to tensorflow graph</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Backpropagation: Define the tensorflow optimizer. Use an AdamOptimizer that minimizes the cost.</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    optimizer = tf.train.AdamOptimizer(learning_rate = learning_rate).minimize(cost)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize all the variables globally</span></span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># Start the session to compute the tensorflow graph</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Run the initialization</span></span><br><span class="line">        sess.run(init)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Do the training loop</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line"></span><br><span class="line">            minibatch_cost = <span class="number">0.</span></span><br><span class="line">            num_minibatches = int(m / minibatch_size) <span class="comment"># number of minibatches of size minibatch_size in the train set</span></span><br><span class="line">            seed = seed + <span class="number">1</span></span><br><span class="line">            minibatches = random_mini_batches(X_train, Y_train, minibatch_size, seed)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> minibatch <span class="keyword">in</span> minibatches:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Select a minibatch</span></span><br><span class="line">                (minibatch_X, minibatch_Y) = minibatch</span><br><span class="line">                <span class="comment"># IMPORTANT: The line that runs the graph on a minibatch.</span></span><br><span class="line">                <span class="comment"># Run the session to execute the optimizer and the cost, the feedict should contain a minibatch for (X,Y).</span></span><br><span class="line">                <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">                _ , temp_cost = sess.run([optimizer,cost], feed_dict = &#123;X:minibatch_X, Y:minibatch_Y&#125;)</span><br><span class="line">                <span class="comment">### END CODE HERE ###</span></span><br><span class="line">                </span><br><span class="line">                minibatch_cost += temp_cost / num_minibatches</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            <span class="comment"># Print the cost every epoch</span></span><br><span class="line">            <span class="keyword">if</span> print_cost == <span class="literal">True</span> <span class="keyword">and</span> epoch % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">&quot;Cost after epoch %i: %f&quot;</span> % (epoch, minibatch_cost))</span><br><span class="line">            <span class="keyword">if</span> print_cost == <span class="literal">True</span> <span class="keyword">and</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                costs.append(minibatch_cost)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># plot the cost</span></span><br><span class="line">        plt.plot(np.squeeze(costs))</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;cost&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;iterations (per tens)&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&quot;Learning rate =&quot;</span> + str(learning_rate))</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate the correct predictions</span></span><br><span class="line">        predict_op = tf.argmax(Z3, <span class="number">1</span>)</span><br><span class="line">        correct_prediction = tf.equal(predict_op, tf.argmax(Y, <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Calculate accuracy on the test set</span></span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">&quot;float&quot;</span>))</span><br><span class="line">        print(accuracy)</span><br><span class="line">        train_accuracy = accuracy.eval(&#123;X: X_train, Y: Y_train&#125;)</span><br><span class="line">        test_accuracy = accuracy.eval(&#123;X: X_test, Y: Y_test&#125;)</span><br><span class="line">        print(<span class="string">&quot;Train Accuracy:&quot;</span>, train_accuracy)</span><br><span class="line">        print(<span class="string">&quot;Test Accuracy:&quot;</span>, test_accuracy)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> train_accuracy, test_accuracy, parameters</span><br></pre></td></tr></table></figure>
<p>Run the following cell to train your model for 100 epochs. Check if your cost after epoch 0 and 5 matches our output. If not, stop the cell and go back to your code!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, _, parameters = model(X_train, Y_train, X_test, Y_test)</span><br></pre></td></tr></table></figure>
<p><strong>Expected output</strong>: although it may not match perfectly, your expected output should be close to ours and your cost value should decrease.</p>
<table>
<tr>
<td>
<strong>Cost after epoch 0 =</strong>
</td>
<td>
1.917929
</td>
</tr>
<tr>
<td>
<strong>Cost after epoch 5 =</strong>
</td>
<td>
1.506757
</td>
</tr>
<tr>
<td>
<strong>Train Accuracy =</strong>
</td>
<td>
0.940741
</td>
</tr>
<tr>
<td>
<strong>Test Accuracy =</strong>
</td>
<td>
0.783333
</td>
</tr>
</table>
<p>Congratulations! You have finised the assignment and built a model that recognizes SIGN language with almost 80% accuracy on the test set. If you wish, feel free to play around with this dataset further. You can actually improve its accuracy by spending more time tuning the hyperparameters, or using regularization (as this model clearly has a high variance).</p>
<p>Once again, here's a thumbs up for your work!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fname = <span class="string">&quot;images/thumbs_up.jpg&quot;</span></span><br><span class="line">image = np.array(ndimage.imread(fname, flatten=<span class="literal">False</span>))</span><br><span class="line">my_image = scipy.misc.imresize(image, size=(<span class="number">64</span>,<span class="number">64</span>))</span><br><span class="line">plt.imshow(my_image)</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/deeplearning-ai/" rel="tag"># deeplearning.ai</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/15/coursera-deeplearning-ai-c3-week3/" rel="prev" title="coursera-deeplearning-ai-c3-week3">
      <i class="fa fa-chevron-left"></i> coursera-deeplearning-ai-c3-week3
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/10/25/coursera-deeplearning-ai-c4-week2/" rel="next" title="coursera-deeplearning-ai-c4-week2">
      coursera-deeplearning-ai-c4-week2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#convolutional-neural-networks"><span class="nav-number">1.1.</span> <span class="nav-text">Convolutional Neural Networks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#computer-vision"><span class="nav-number">1.1.1.</span> <span class="nav-text">Computer Vision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#edge-detection-example"><span class="nav-number">1.1.2.</span> <span class="nav-text">Edge Detection Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#more-edge-detection"><span class="nav-number">1.1.3.</span> <span class="nav-text">More Edge Detection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#padding"><span class="nav-number">1.1.4.</span> <span class="nav-text">Padding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strided-convolutions"><span class="nav-number">1.1.5.</span> <span class="nav-text">Strided Convolutions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#convolutions-over-volume"><span class="nav-number">1.1.6.</span> <span class="nav-text">Convolutions Over Volume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-layer-of-a-convolutional-network"><span class="nav-number">1.1.7.</span> <span class="nav-text">One Layer of a Convolutional Network</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simple-convolutional-network-example"><span class="nav-number">1.1.8.</span> <span class="nav-text">Simple Convolutional Network Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pooling-layers"><span class="nav-number">1.1.9.</span> <span class="nav-text">Pooling Layers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cnn-example"><span class="nav-number">1.1.10.</span> <span class="nav-text">CNN Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#why-convolutions"><span class="nav-number">1.1.11.</span> <span class="nav-text">Why Convolutions?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">编程练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#convolutional-neural-networks-step-by-step"><span class="nav-number">2.1.</span> <span class="nav-text">Convolutional Neural Networks: Step by Step</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#packages"><span class="nav-number">2.1.1.</span> <span class="nav-text">1 - Packages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#outline-of-the-assignment"><span class="nav-number">2.1.2.</span> <span class="nav-text">2 - Outline of the Assignment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#convolutional-neural-networks-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">3 - Convolutional Neural Networks</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#zero-padding"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.1 - Zero-Padding</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#single-step-of-convolution"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.2 - Single step of convolution</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#convolutional-neural-networks---forward-pass"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3.3 - Convolutional Neural Networks - Forward pass</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pooling-layer"><span class="nav-number">2.1.4.</span> <span class="nav-text">4 - Pooling layer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forward-pooling"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">4.1 - Forward Pooling</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#backpropagation-in-convolutional-neural-networks-optional-ungraded"><span class="nav-number">2.1.5.</span> <span class="nav-text">5 - Backpropagation in convolutional neural networks (OPTIONAL &#x2F; UNGRADED)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#convolutional-layer-backward-pass"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">5.1 - Convolutional layer backward pass</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#computing-da"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">5.1.1 - Computing dA</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#computing-dw"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">5.1.2 - Computing dW</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#computing-db"><span class="nav-number">2.1.5.2.1.</span> <span class="nav-text">5.1.3 - Computing db</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pooling-layer---backward-pass"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">5.2 Pooling layer - backward pass</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#max-pooling---backward-pass"><span class="nav-number">2.1.5.3.1.</span> <span class="nav-text">5.2.1 Max pooling - backward pass</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#average-pooling---backward-pass"><span class="nav-number">2.1.5.3.2.</span> <span class="nav-text">5.2.2 - Average pooling - backward pass</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#putting-it-together-pooling-backward"><span class="nav-number">2.1.5.3.3.</span> <span class="nav-text">5.2.3 Putting it together: Pooling backward</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#congratulations"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">Congratulations !</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#convolutional-neural-networks-application"><span class="nav-number">2.2.</span> <span class="nav-text">Convolutional Neural Networks: Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tensorflow-model"><span class="nav-number">2.2.1.</span> <span class="nav-text">1 - TensorFlow model</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#create-placeholders"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.1 - Create placeholders</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#initialize-parameters"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">1.2 - Initialize parameters</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-propagation"><span class="nav-number">2.2.2.</span> <span class="nav-text">2 - Forward propagation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compute-cost"><span class="nav-number">2.2.3.</span> <span class="nav-text">3 - Compute cost</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#model"><span class="nav-number">2.2.4.</span> <span class="nav-text">4 Model</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张阿楠"
      src="/images/wukong.png">
  <p class="site-author-name" itemprop="name">张阿楠</p>
  <div class="site-description" itemprop="description">Keep codeing and thinking!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Vernlium" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Vernlium" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhanganan0425@163.com" title="E-Mail → mailto:zhanganan0425@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张阿楠</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '94b49fdac7c9894db657',
      clientSecret: 'aae2bc06bd829867f3212474d4698cfec26386d6',
      repo        : 'vernlium.github.io',
      owner       : 'Vernlium',
      admin       : ['Vernlium'],
      id          : 'b36e46a744f4216dfd3efc6f3b026a09',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
