<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-wukong.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-wukong.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vernlium.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="课程笔记 本周课程主要讲了卷积神经网络在其他领域的应用，要点： - 艺术风格转换 - 人脸识别">
<meta property="og:type" content="article">
<meta property="og:title" content="coursera-deeplearning-ai-c4-week4">
<meta property="og:url" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/index.html">
<meta property="og:site_name" content="Vernlium">
<meta property="og:description" content="课程笔记 本周课程主要讲了卷积神经网络在其他领域的应用，要点： - 艺术风格转换 - 人脸识别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/face_verification_vs_face_recognition.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/siamese_network.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/goal_of_learning.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/learning_objective.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/triplet_loss_function.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/choosing_the_triplets_a_p_n.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/learning_the_similarity_function.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/training_set_similarity_function.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/neural_style_transfer_examples.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/visualizing_what_a_deep_network_is_learning.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/find_the_generated_image.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/content_cost_function.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/meaning_of_the_style_of_an_image.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/style_matrix.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/style_cost_function.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/convolutions_in_2d_and_1d_and_3d.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/louvre_generated.png">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/output_of_cimages.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/NST_LOSS.png">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/output_of_simages.jpg">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/louvre_generated.png">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/perspolis_vangogh.png">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/pasargad_kashi.png">
<meta property="og:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/circle_abstract.png">
<meta property="article:published_time" content="2018-11-24T23:16:45.000Z">
<meta property="article:modified_time" content="2020-10-17T13:11:22.869Z">
<meta property="article:author" content="张阿楠">
<meta property="article:tag" content="deeplearning.ai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/face_verification_vs_face_recognition.jpg">

<link rel="canonical" href="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>coursera-deeplearning-ai-c4-week4 | Vernlium</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vernlium</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Keep codeing and thinking!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vernlium.github.io/2018/11/25/coursera-deeplearning-ai-c4-week4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wukong.png">
      <meta itemprop="name" content="张阿楠">
      <meta itemprop="description" content="Keep codeing and thinking!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vernlium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          coursera-deeplearning-ai-c4-week4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-25 07:16:45" itemprop="dateCreated datePublished" datetime="2018-11-25T07:16:45+08:00">2018-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-17 21:11:22" itemprop="dateModified" datetime="2020-10-17T21:11:22+08:00">2020-10-17</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="课程笔记">课程笔记</h2>
<p>本周课程主要讲了卷积神经网络在其他领域的应用，要点： - 艺术风格转换 - 人脸识别</p>
<p>学习目标：</p>
<ul>
<li>Discover how CNNs can be applied to multiple fields, including art generation and face recognition. Implement your own algorithm to generate art and recognize faces!</li>
</ul>
<h3 id="face-recognition">Face Recognition</h3>
<h4 id="what-is-face-recognition">What is face recognition?</h4>
<p>人脸设别和人脸验证的区别：</p>
<ul>
<li>人脸验证
<ul>
<li>输入一副图片，包含名字或ID</li>
<li>输出输入普通是否是要确认的人</li>
</ul></li>
<li>人脸识别
<ul>
<li>一个数据库，包含K个人</li>
<li>有个输入图片</li>
<li>如果图片是数据库中任何K个人之一，输出这个人的ID，否则输出无法识别</li>
</ul></li>
</ul>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/face_verification_vs_face_recognition.jpg" class="" title="Face verification VS Face Recognition">
<h4 id="one-shot-learning">One Shot Learning</h4>
<p>One shot Learning问题是指，仅仅从一个实例再次识别这个人。</p>
<p>Learning from one example to recognize the person again。</p>
<p>通过相似度函数来解决此问题。相似度函数定义为：</p>
<p>$ d(img1,img2) = degree, of ,difference, between ,images$</p>
<p>这个函数是用来描述两幅图片的相似度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If d(img1,img2)  ≤ 𝜏  , same person</span><br><span class="line">                 &gt; 𝜏  , diff person</span><br></pre></td></tr></table></figure>
<h4 id="siamese-network孪生网络">Siamese Network（孪生网络）</h4>
<p>上一节中学到，函数d的任务是接受两张脸的输入，并输出它们有多相似，或有多不同。 实现这个的一个好办法是Siamese网络。</p>
<p>把输入人脸图片经过一个卷积神经网络推理后，得到了一个特征向量（softmax的前一层）。有时候把它输入到一个softmax层中，去做分类。 这儿不这样做，而是专注在这个向量本身，比如说128个数，它由神经网络深处的某个全连接层计算而来。</p>
<p>给这128个数(组成的向量）起个名字，把它叫做 <span class="math inline">\(f(x^{(1)})\)</span> 大家可以把f(x1)看成是输入图片x1的编码。同样将第二张图片输入到同一个网络，使用相同的参数，得到一个不同的，128个数字组成的向量，这是第二张图片的编码。 称之为第二张图片的编码，即<span class="math inline">\(f(x^{(2)}\)</span>。最后，定义距离d是x1和 x2这两张图片的编码之间差的范数。</p>
<p>这种方法，用两个完全相同的卷积神经网络对两张不同的图片进行计算，比较二者的结果，有时称之为<strong>孪生网络（Siamese Network）</strong>架构。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/siamese_network.jpg" class="" title="Siamese Network">
<p>该如何训练Siamese Network?</p>
<p>训练一个神经网络，使得它计算的编码可以生成一个函数d来判断这两张照片是同一个人的。更正式的来说，神经网络的参数定义了编码f（xi），当给定输入图片xi， 这个神经网络输出这个128维的编码 f(xi)。如果两张图片xi和xj上是同一个人，那么他们的编码的差距就会小。相反的，如果xi和xj上是不同的人，那么你就想要他们的编码的差距大。 因此, 当神经网中层的参数时, 最终会有不同的编码。可以通过反向传播来更改参数以确保满足这些条件。但如何定义一个目标函数让神经网络学会做这些事情？ 需要使用三重损耗函数（triplet loss function）。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/goal_of_learning.jpg" class="" title="Goal of Learning">
<h4 id="triplet-loss">Triplet Loss</h4>
<p>把输入图片分为锚照片，正例照片和负例照片，将把锚照片正例照片和负例照片简写为， A (anchor)，P (positive) 和 N (negative)。需要做的是使神经网络中的参数获得以下性质，将<strong>锚照片的编码减去正例照片的编码</strong>，这个差很小，而且希望这个差小于等于<strong>锚照片的编码和负例照片的编码之间差距的平方</strong>。左边是d(A,P)（A和P的距离），而右边是d(A,N)（A和N的距离）。可以把d想象成距离方程， 用字母d命名。</p>
<p>把右边的式子移到左边来，将会得到 f(A)减去f(P)的平方，减去，右手边的式子， f(A)减去f(N)的平方， 小于等于0。有一个情况会使式子的条件轻易得到满足，是把每一项学习成0。 如果f()永远等于0， 那这就是0减去0， 也就是0，这也是0减去0得到0。 如果说f(任何照片)得到的是一个全是0的量，可以永远满足这个式子的条件（小于等于0）。 所以，为了确保神经网络不会为所有编码都一直输出0， 为了确保它不会把这些编码训练得和其他的一样。另一个使神经网络给出一个退化的输出的情况是， 如果每一张照片的编码都和其他任何一张照片的编码完全相同，将再次得到0减去0等于0。 所以为了防止神经网络做这些事，需要做的是调整这个式子， 使它不仅仅小于等于0， 而是比0小很多。 所以，比如说我们想要这个式子小于 负alpha, 这里的<strong>alpha是另外一个超参数</strong>， 这样可以防止神经网络输出退化解。</p>
<p>按照惯例，通常在在左边写成正alpha而不是在右边的负alpha。 这也被称为<strong>margin</strong>（支持向量机中的术语）。alpha代表d(A,P)和d(A,N)之间的差距，这就是margin参数的用途， 它可以拉大 d(A,P)和d(A,N)之间的差距。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/learning_objective.jpg" class="" title="Learning Object">
<p>根据上面的分析，可以定义<strong>三元组损失函数</strong>如下图所示：</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/triplet_loss_function.jpg" class="" title="Triplet Loss Function">
<p>三元组损失函数由一组中的三张照片而得名，有3张照片， A，P和N， 分别代表锚照片，正例照片和负例照片。 正例照片与锚照片中的人相同， 而负例照片和锚照片中的人不同。 损失函数的定义为：</p>
<p><span class="math display">\[
L( {A,P,N} ) = max( {\mathop {\| {f( A ) - f( P )} \|}\nolimits^2  - \mathop {\| {f( A ) - f( N )} \|}\nolimits^2  + \alpha ,0} )
\]</span></p>
<p>这里取最大值的效果是只要前面一项小于0， 那么“损失“便为0， 因为一个小于0的值和0之间的最大值 一定是0。</p>
<p>而神经网络中整体损失函数可以是一套训练集中不同三元组对应的“损失“的总和。 假如有一个训练集，其中包含1000个不同的人组成的10000张照片，需要做的是用这10000张照片去生成[A,P,N]这样的三元组，然后使用梯度下降法训练这个损失函数。请注意，如果要定义三元组的数据集，需要一些成对的A和P，也就是一对包含同一人的照片。 所以为了达到训练的目的， 必须要求数据集中同一个人会有数张不同的照片。 所以要求10000张包含1000个不同人的照片， 这样1000人中每个人平均会有10张照片， 来组成整个数据集。 如果每个人只有一张照片，那么无法训练这个系统。当然，在训练好了这个系统后， 可以将其应用在人脸识别系统的一次性的学习任务， 其中可能只有某个想要识别的人的一张照片。 但对于训练集来说，需要确保训练集中的至少其中一部分人会有数张照片，使得可以有成对的锚照片和正向照片。</p>
<p>现在，应该如何正确的选择三元组来组成你的训练集呢？ 这里的问题之一是，如果从训练集中随机选择A，P和N，并使A，P为相同的人，而A，N为不同的人。 有个问题是如果随机选择它们， 那么这个约束将会非常容易得到满足， 因为如果有两张随机选出的照片， A，N之间的差异会远远大于A，P之间的差异。那么神经网络无法从中学习很多。 所以要建立一个训练集，要做的是选择训练起来比较难的三元组A，P和N。 具体来说想要的是所有满足这个约束的三元组， 还需要是一个相对难以训练的三元组，难训练是说A，P，N会使得d(A,P)和d(A,N)相当接近。 这么一来， 学习算法需要更加努力来使得右边的值增加或是左边的值减少，这样才能使代表左右差距的alpha有意义。</p>
<p>选择这些三元组的效果是增强你的学习算法的计算效率。 如果随机选择三元组， 那么很多三元组会是非常简单的， 那么梯度下降无法做任何事，因为神经网络本来就能做对它们。 因此只能通过有难度的三元组来使梯度下降能做到把这两项之间的距离分得更开。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/choosing_the_triplets_a_p_n.jpg" class="" title="Choosing the triplets A,P,N">
<p>顺便一提，对于深度学习领域内如何命名算法有个有趣的事实，如果研究某一领域，那么我们称它&quot;<strong>&quot;， 你常会有一个系统叫 &quot;</strong>&quot;网络(<strong>net) 或者 深度&quot;</strong>&quot;(deep __)。</p>
<h4 id="face-verification-and-binary-classification">Face Verification and Binary Classification</h4>
<p>Triplet Loss是一种学习用于人脸识别的ConvNet的参数的好办法,还有一种方法可以用来学习这些参数。就是将人脸识别当做一种直接的二元分类问题。</p>
<p>这种训练神经网络的方法是利用这一对神经网络，这个Siamese网络让他们都计算这些embeddings，可能有128维的embeddings，也许有更高的维度，然后将这些输入到一个逻辑回归单元后做出预测。如果这两个是同一个人,目标结果将会输出1。如果是两个不同的人,结果将会输出0。所以，这是一种将人脸识别当做二元分类的方法。</p>
<p><span class="math display">\[
\hat y = \sigma (  \sum \limits_{k = 1}^{128} {w_i}| {f{(x^{( i )} )_k} - f{( x^{( j )})}_k} | + b )
\]</span></p>
<p>f(x(i))k是图片x(i)的编码，下标k代表选择这个向量的第k个元素，对这两个编码，取元素差的绝对值。与之前类似，训练的也是一个siamese网络，这意味着上面的那个神经网络和下面的网络具有相同的参数，这样的系统效果也很好。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/learning_the_similarity_function.jpg" class="" title="Learning the similarity function">
<p>可以将人脸验证当作一个监督学习，创建一个只有成对图片的训练集，不是三个一组而是成对的照片，目标标签是1表示一对照片是同一个人，目标标签是0表示图片中是不同的人。如下图所示：</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/training_set_similarity_function.jpg" class="">
<h3 id="neural-style-transfer">Neural Style Transfer</h3>
<h4 id="what-is-neural-style-transfer">What is neural style transfer?</h4>
<p>什么是神经风格转换？</p>
<p>简而言之，就是利用一张内容图片和一张风格图片，生成一张新的图片，这张图片有一种艺术风格，如图所示：</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/neural_style_transfer_examples.jpg" class="" title="Neural Style Transfer Examples">
<h4 id="what-are-deep-convnets-learning">What are deep ConvNets learning?</h4>
<p>可以通过可视化来查看卷积神经网络学习到的是什么。下图是可视化的方法。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/visualizing_what_a_deep_network_is_learning.jpg" class="" title="Visualizing what a deep network is learning">
<p>下图是把卷积神经网络可视化后的每一层的示例。 我们可以看到，第一层，学习到的都是一些低层次的特征，比如水平或者垂直边缘等。第二层可能是一些纹理的特征，越往后学习到的就是越复杂、越整体的特征。</p>

<h4 id="cost-function">Cost Function</h4>
<p>要构建一个神经风格迁移系统，我们需要定义一个代价函数，通过最小化代价函数，生成我们想要的任何图像。我们的问题是，给定一个内容图像C，和一个风格图像S，生成一下新图象G。其中代价函数分为两部分，一部分是内容代价函数，一部分是风格代价函数。内容代价函数是用来衡量生成图片G的内容和内容图片C的内容的相似度，风格代价用来衡量生成图片G的风格和和图片S的风格的相似度，最后利用两个超参数来确定内容代价和风格代价之间的权重。代价函数如下： <span class="math display">\[
J( G ) = \alpha  \times J_{content}( {C,G} ) + \beta  \times J_{style}( {S,G} )
\]</span></p>
<p>定义了损失函数之后，要做的就是通过梯度下降法进行学习，使得生成的图片满足<span class="math inline">\(J( G )\)</span>很小。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/find_the_generated_image.jpg" class="" title="Find the generated image G">
<h4 id="content-cost-function">Content Cost Function</h4>
<p>假如用隐藏层来计算内容代价函数，如果层数太小，这个代价函数就会使的生成图片像素上非常接近内容图片，然而如果用很深的层，那么如果内容图片有一只狗，他就会确保生成图片有一只狗，所以在实际中，这个层l在网络中既不会选的太浅，也不会选的太深，通常l会选在中间层，然后用一个与训练的卷积模型如VGG，其他的也可以。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/content_cost_function.jpg" class="" title="Content cost function">
<p>内容代价函数如下：</p>
<p><span class="math display">\[
J_{content}( {C,G} ) = \frac{1}{2}{\| a^{[ l ]( C )} - a^{[ l ]( G )} \|^2}
\]</span></p>
<p>其中<span class="math inline">\(a^{[l](C)}\)</span>表示内容图片在l层的激活值，从公式可以看出，如果这两个激活值相似，即<span class="math inline">\(J_{content}( {C,G} )\)</span>越小，那么就意味着两个图片的内容相似。</p>
<h4 id="style-cost-function">Style Cost Function</h4>
<p>假设选择了某一层L,我们要做的是将风格定义为层中<strong>不同激活通道之间的相关系数</strong>。具体是这样的，假设选择了激活层L，是一个nh乘nw乘nc的激活阵，然后我们想知道的是，不同的激活通道间的相关性有多大。</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/meaning_of_the_style_of_an_image.jpg" class="" title="Meaning of the “style” of an image">
<p>对于两个图像，也就是风格图像和生成图像，需要计算一个风格矩阵，更具体一点，就是用<span class="math inline">\(l\)</span>层来测量风格。我们设<span class="math inline">\(a_{(i,j,k)}\)</span>为隐藏层中<span class="math inline">\(a_{(i,j,k)}\)</span>位置的激活项，i，j，k分别代表位置的高，宽，以及通道数。</p>
<p>同样的我们对生成的图像也进行这个操作。我们先来定义风格图像，设这个关于l层和风格图像的G是一个矩阵，这个矩阵的宽度和高度都是l层的通道数，在这个矩阵中，kk和k′k′被用来描述k通道和k′通道之间的相关系数，具体的用符号i,j表示下界，对i，j，k位置的激活项乘以同样位置的激活项，也就是i，j，k′k′位置的激活项，将它们相层，然后i和j分别到l层的高度和宽度，将这不同位置的激活项加起来，如下公式所示：</p>
<p><span class="math display">\[
G_{kk&#39;}^{[l]( s )} = \sum \limits_{i = 1}^{n_H^{[l]}} \sum \limits_{j = 1}^{n_w^{[l]}} a_{ijk}^{[l]( s )}a_{ijk&#39;}^{[l]( s )}
\]</span></p>
<p>上面就是输入的风格图像所构成的风格矩阵。 然后我们对生成图像做同样的操作故其风格矩阵如下：</p>
<p><span class="math display">\[
G_{kk&#39;}^{[ l ]( G )} =  \sum \limits_{i = 1}^{n_H^{[ l ]}}  \sum \limits_{j = 1}^{n_w^{[l]}} a_{ijk}^{[ l ]( G )}a_{ijk&#39;}^{[ l ]( G)}
\]</span></p>
<p><span class="math inline">\(G_{kk&#39;}^{[l](G)}\)</span>可以用来测量k通道与k′通道中的相关系数，k和k′k′在1到n_c之间取值。其实<span class="math inline">\(G_{kk&#39;}^{[l](G)}\)</span>是一种非标准的互协方差，因为我们并没有减去均值，而是直接将他们相乘。这就是计算风格的方法。由上述我们就可以定义l层风格损失函数了。如下所示：</p>
<p><span class="math display">\[
\mathop J\nolimits_{style}^{[ l ]} ( {S,G} ) = \mathop {\| G^{[ l ](S)} - G^{[ l ](G)} \|}\nolimits_F^2
\]</span></p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/style_matrix.jpg" class="" title="Style Matrix">
<p>这里其实还可以采用归一化操作，不在赘述。 如果我们对各层都使用风格代价函数的话，会让效果变得更好，此时可以定义如下代价函数。</p>
<p><span class="math display">\[
J_{style}( {S,G} ) = \sum\limits_l {\mathop \lambda \nolimits^l } \mathop J\nolimits_{style}^{[ l ]} ( {S,G} )
\]</span></p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/style_cost_function.jpg" class="" title="Style Cost Function">
<h4 id="d-and-3d-generalizations">1D and 3D Generalizations</h4>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/convolutions_in_2d_and_1d_and_3d.jpg" class="" title="Convolutions in 2D and 1D and 3D">
<h2 id="编程练习">编程练习</h2>
<h3 id="deep-learning-art-neural-style-transfer">Deep Learning &amp; Art: Neural Style Transfer</h3>
<p>Welcome to the second assignment of this week. In this assignment, you will learn about Neural Style Transfer. This algorithm was created by Gatys et al. (2015) (https://arxiv.org/abs/1508.06576).</p>
<p><strong>In this assignment, you will:</strong> - Implement the neural style transfer algorithm - Generate novel artistic images using your algorithm</p>
<p>Most of the algorithms you've studied optimize a cost function to get a set of parameter values. In Neural Style Transfer, you'll optimize a cost function to get pixel values!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> imshow</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> nst_utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">get_ipython().magic(<span class="string">&#x27;matplotlib inline&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="problem-statement">1 - Problem Statement</h4>
<p>Neural Style Transfer (NST) is one of the most fun techniques in deep learning. As seen below, it merges two images, namely, a &quot;content&quot; image (C) and a &quot;style&quot; image (S), to create a &quot;generated&quot; image (G). The generated image G combines the &quot;content&quot; of the image C with the &quot;style&quot; of image S.</p>
<p>In this example, you are going to generate an image of the Louvre museum in Paris (content image C), mixed with a painting by Claude Monet, a leader of the impressionist movement (style image S).</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/louvre_generated.png" class="" title="Louvre Generated">
<p>Let's see how you can do this.</p>
<h4 id="transfer-learning">2 - Transfer Learning</h4>
<p>Neural Style Transfer (NST) uses a previously trained convolutional network, and builds on top of that. The idea of using a network trained on a different task and applying it to a new task is called transfer learning.</p>
<p>Following the original NST paper (https://arxiv.org/abs/1508.06576), we will use the VGG network. Specifically, we'll use VGG-19, a 19-layer version of the VGG network. This model has already been trained on the very large ImageNet database, and thus has learned to recognize a variety of low level features (at the earlier layers) and high level features (at the deeper layers).</p>
<p>Run the following code to load parameters from the VGG model. This may take a few seconds.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model = load_vgg_model(<span class="string">&quot;pretrained-model/imagenet-vgg-verydeep-19.mat&quot;</span>)</span><br><span class="line">print(model)</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#39;input&#39;: &lt;tf.Variable &#39;Variable:0&#39; shape&#x3D;(1, 300, 400, 3) dtype&#x3D;float32_ref&gt;, </span><br><span class="line">	&#39;conv1_1&#39;: &lt;tf.Tensor &#39;Relu:0&#39; shape&#x3D;(1, 300, 400, 64) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv1_2&#39;: &lt;tf.Tensor &#39;Relu_1:0&#39; shape&#x3D;(1, 300, 400, 64) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;avgpool1&#39;: &lt;tf.Tensor &#39;AvgPool:0&#39; shape&#x3D;(1, 150, 200, 64) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv2_1&#39;: &lt;tf.Tensor &#39;Relu_2:0&#39; shape&#x3D;(1, 150, 200, 128) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv2_2&#39;: &lt;tf.Tensor &#39;Relu_3:0&#39; shape&#x3D;(1, 150, 200, 128) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;avgpool2&#39;: &lt;tf.Tensor &#39;AvgPool_1:0&#39; shape&#x3D;(1, 75, 100, 128) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv3_1&#39;: &lt;tf.Tensor &#39;Relu_4:0&#39; shape&#x3D;(1, 75, 100, 256) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv3_2&#39;: &lt;tf.Tensor &#39;Relu_5:0&#39; shape&#x3D;(1, 75, 100, 256) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv3_3&#39;: &lt;tf.Tensor &#39;Relu_6:0&#39; shape&#x3D;(1, 75, 100, 256) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv3_4&#39;: &lt;tf.Tensor &#39;Relu_7:0&#39; shape&#x3D;(1, 75, 100, 256) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;avgpool3&#39;: &lt;tf.Tensor &#39;AvgPool_2:0&#39; shape&#x3D;(1, 38, 50, 256) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv4_1&#39;: &lt;tf.Tensor &#39;Relu_8:0&#39; shape&#x3D;(1, 38, 50, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv4_2&#39;: &lt;tf.Tensor &#39;Relu_9:0&#39; shape&#x3D;(1, 38, 50, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv4_3&#39;: &lt;tf.Tensor &#39;Relu_10:0&#39; shape&#x3D;(1, 38, 50, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv4_4&#39;: &lt;tf.Tensor &#39;Relu_11:0&#39; shape&#x3D;(1, 38, 50, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;avgpool4&#39;: &lt;tf.Tensor &#39;AvgPool_3:0&#39; shape&#x3D;(1, 19, 25, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv5_1&#39;: &lt;tf.Tensor &#39;Relu_12:0&#39; shape&#x3D;(1, 19, 25, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv5_2&#39;: &lt;tf.Tensor &#39;Relu_13:0&#39; shape&#x3D;(1, 19, 25, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv5_3&#39;: &lt;tf.Tensor &#39;Relu_14:0&#39; shape&#x3D;(1, 19, 25, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;conv5_4&#39;: &lt;tf.Tensor &#39;Relu_15:0&#39; shape&#x3D;(1, 19, 25, 512) dtype&#x3D;float32&gt;, </span><br><span class="line">	&#39;avgpool5&#39;: &lt;tf.Tensor &#39;AvgPool_4:0&#39; shape&#x3D;(1, 10, 13, 512) dtype&#x3D;float32&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The model is stored in a python dictionary where each variable name is the key and the corresponding value is a tensor containing that variable's value. To run an image through this network, you just have to feed the image to the model. In TensorFlow, you can do so using the <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/assign">tf.assign</a> function. In particular, you will use the assign function like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model[<span class="string">&quot;input&quot;</span>].assign(image)</span><br></pre></td></tr></table></figure>
<p>This assigns the image as an input to the model. After this, if you want to access the activations of a particular layer, say layer <code>4_2</code> when the network is run on this image, you would run a TensorFlow session on the correct tensor <code>conv4_2</code>, as follows:<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sess.run(model[<span class="string">&quot;conv4_2&quot;</span>])</span><br></pre></td></tr></table></figure></p>
<h4 id="neural-style-transfer-1">3 - Neural Style Transfer</h4>
<p>We will build the NST algorithm in three steps:</p>
<ul>
<li>Build the content cost function <span class="math inline">\(J_{content}(C,G)\)</span></li>
<li>Build the style cost function <span class="math inline">\(J_{style}(S,G)\)</span></li>
<li>Put it together to get <span class="math inline">\(J(G) = \alpha J_{content}(C,G) + \beta J_{style}(S,G)\)</span>.</li>
</ul>
<h5 id="computing-the-content-cost">3.1 - Computing the content cost</h5>
<p>In our running example, the content image C will be the picture of the Louvre Museum in Paris. Run the code below to see a picture of the Louvre.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content_image = scipy.misc.imread(<span class="string">&quot;images/louvre.jpg&quot;</span>)</span><br><span class="line">imshow(content_image)</span><br></pre></td></tr></table></figure>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/output_of_cimages.jpg" class="">
<p>The content image (C) shows the Louvre museum's pyramid surrounded by old Paris buildings, against a sunny sky with a few clouds.</p>
<p>** 3.1.1 - How do you ensure the generated image G matches the content of the image C?**</p>
<p>As we saw in lecture, the earlier (shallower) layers of a ConvNet tend to detect lower-level features such as edges and simple textures, and the later (deeper) layers tend to detect higher-level features such as more complex textures as well as object classes.</p>
<p>We would like the &quot;generated&quot; image G to have similar content as the input image C. Suppose you have chosen some layer's activations to represent the content of an image. In practice, you'll get the most visually pleasing results if you choose a layer in the middle of the network--neither too shallow nor too deep. (After you have finished this exercise, feel free to come back and experiment with using different layers, to see how the results vary.)</p>
<p>So, suppose you have picked one particular hidden layer to use. Now, set the image C as the input to the pretrained VGG network, and run forward propagation. Let <span class="math inline">\(a^{(C)}\)</span> be the hidden layer activations in the layer you had chosen. (In lecture, we had written this as <span class="math inline">\(a^{[l](C)}\)</span>, but here we'll drop the superscript <span class="math inline">\([l]\)</span> to simplify the notation.) This will be a <span class="math inline">\(n_H \times n_W \times n_C\)</span> tensor. Repeat this process with the image G: Set G as the input, and run forward progation. Let <span class="math display">\[a^{(G)}\]</span> be the corresponding hidden layer activation. We will define as the content cost function as:</p>
<p><span class="math display">\[J_{content}(C,G) =  \frac{1}{4 \times n_H \times n_W \times n_C}\sum _{ \text{all entries}} (a^{(C)} - a^{(G)})^2 \]</span></p>
<p>Here, $ n_H,n_W $ and $ n_C $ are the height, width and number of channels of the hidden layer you have chosen, and appear in a normalization term in the cost. For clarity, note that $ a^{(C)} $ and $ a^{(G)} $ are the volumes corresponding to a hidden layer's activations. In order to compute the cost $ J_{content}(C,G) $, it might also be convenient to unroll these 3D volumes into a 2D matrix, as shown below. (Technically this unrolling step isn't needed to compute $ J_{content} $, but it will be good practice for when you do need to carry out a similar operation later for computing the style const $ J_{style} $.)</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/NST_LOSS.png" class="" title="NST LOSS">
<p><strong>Exercise:</strong> Compute the &quot;content cost&quot; using TensorFlow.</p>
<p><strong>Instructions</strong>: The 3 steps to implement this function are: 1. Retrieve dimensions from a_G: - To retrieve dimensions from a tensor X, use: <code>X.get_shape().as_list()</code> 2. Unroll a_C and a_G as explained in the picture above - If you are stuck, take a look at <a target="_blank" rel="noopener" href="https://www.tensorflow.org/versions/r1.3/api_docs/python/tf/transpose">Hint1</a> and <a target="_blank" rel="noopener" href="https://www.tensorflow.org/versions/r1.2/api_docs/python/tf/reshape">Hint2</a>. 3. Compute the content cost: - If you are stuck, take a look at <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/reduce_sum">Hint3</a>, <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/square">Hint4</a> and <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/subtract">Hint5</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GRADED FUNCTION: compute_content_cost</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_content_cost</span>(<span class="params">a_C, a_G</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes the content cost</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    a_C -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing content of the image C </span></span><br><span class="line"><span class="string">    a_G -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing content of the image G</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns: </span></span><br><span class="line"><span class="string">    J_content -- scalar that you compute using equation 1 above.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Retrieve dimensions from a_G (≈1 line)</span></span><br><span class="line">    m, n_H, n_W, n_C = a_G.get_shape().as_list()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Reshape a_C and a_G (≈2 lines)</span></span><br><span class="line">    a_C_unrolled = tf.reshape(a_C, (m, n_H * n_W, n_C))</span><br><span class="line">    a_G_unrolled = tf.reshape(a_G, (m, n_H * n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># compute the cost with tensorflow (≈1 line)</span></span><br><span class="line">    J_content = tf.reduce_sum(tf.square(tf.subtract(a_C_unrolled,a_G_unrolled))) / (<span class="number">4</span> * n_H * n_W * n_C)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> J_content</span><br></pre></td></tr></table></figure>
<p><font color='blue'> <strong>What you should remember</strong>: - The content cost takes a hidden layer activation of the neural network, and measures how different <span class="math inline">\(a^{(C)}\)</span> and <span class="math inline">\(a^{(G)}\)</span> are. - When we minimize the content cost later, this will help make sure <span class="math inline">\(G\)</span> has similar content as <span class="math inline">\(C\)</span>. </font></p>
<h5 id="computing-the-style-cost">3.2 - Computing the style cost</h5>
<p>For our running example, we will use the following style image:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style_image = scipy.misc.imread(<span class="string">&quot;images/monet_800600.jpg&quot;</span>)</span><br><span class="line">imshow(style_image)</span><br></pre></td></tr></table></figure>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/output_of_simages.jpg" class="">
<p>This painting was painted in the style of <em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Impressionism">impressionism</a></em>.</p>
<p>Lets see how you can now define a &quot;style&quot; const function <span class="math inline">\(J_{style}(S,G)\)</span>.</p>
<h5 id="style-matrix">3.2.1 - Style matrix</h5>
<p>The style matrix is also called a &quot;Gram matrix.&quot; In linear algebra, the Gram matrix G of a set of vectors <span class="math inline">\((v_{1},\dots ,v_{n})\)</span> is the matrix of dot products, whose entries are <span class="math inline">\({\displaystyle G_{ij} = v_{i}^T v_{j} = np.dot(v_{i}, v_{j}) }\)</span>. In other words, <span class="math inline">\(G_{ij}\)</span> compares how similar <span class="math inline">\(v_i\)</span> is to <span class="math inline">\(v_j\)</span>: If they are highly similar, you would expect them to have a large dot product, and thus for <span class="math inline">\(G_{ij}\)</span> to be large.</p>
<p>Note that there is an unfortunate collision in the variable names used here. We are following common terminology used in the literature, but <span class="math inline">\(G\)</span> is used to denote the Style matrix (or Gram matrix) as well as to denote the generated image <span class="math inline">\(G\)</span>. We will try to make sure which <span class="math inline">\(G\)</span> we are referring to is always clear from the context.</p>
<p>In NST, you can compute the Style matrix by multiplying the &quot;unrolled&quot; filter matrix with their transpose:</p>

<p>The result is a matrix of dimension <span class="math inline">\((n_C,n_C)\)</span> where <span class="math inline">\(n_C\)</span> is the number of filters. The value <span class="math inline">\(G_{ij}\)</span> measures how similar the activations of filter <span class="math inline">\(i\)</span> are to the activations of filter <span class="math inline">\(j\)</span>.</p>
<p>One important part of the gram matrix is that the diagonal elements such as <span class="math inline">\(G_{ii}\)</span> also measures how active filter <span class="math inline">\(i\)</span> is. For example, suppose filter <span class="math inline">\(i\)</span> is detecting vertical textures in the image. Then <span class="math inline">\(G_{ii}\)</span> measures how common vertical textures are in the image as a whole: If <span class="math inline">\(G_{ii}\)</span> is large, this means that the image has a lot of vertical texture.</p>
<p>By capturing the prevalence of different types of features (<span class="math inline">\(G_{ii}\)</span>), as well as how much different features occur together (<span class="math inline">\(G_{ij}\)</span>), the Style matrix <span class="math inline">\(G\)</span> measures the style of an image.</p>
<p><strong>Exercise</strong>: Using TensorFlow, implement a function that computes the Gram matrix of a matrix A. The formula is: The gram matrix of A is <span class="math inline">\(G_A = AA^T\)</span>. If you are stuck, take a look at <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/matmul">Hint 1</a> and <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/transpose">Hint 2</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GRADED FUNCTION: gram_matrix</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gram_matrix</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    A -- matrix of shape (n_C, n_H*n_W)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    GA -- Gram matrix of A, of shape (n_C, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈1 line)</span></span><br><span class="line">    GA = tf.matmul( A, A, transpose_b=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> GA</span><br></pre></td></tr></table></figure>
<h5 id="style-cost">3.2.2 - Style cost</h5>
<p>After generating the Style matrix (Gram matrix), your goal will be to minimize the distance between the Gram matrix of the &quot;style&quot; image S and that of the &quot;generated&quot; image G. For now, we are using only a single hidden layer <span class="math inline">\(a^{[l]}\)</span>, and the corresponding style cost for this layer is defined as:</p>
<p><span class="math display">\[ J_{style}^{[l]}(S,G) = \frac{1}{4 \times {n_C}^2 \times (n_H \times n_W)^2} \sum _{i=1}^{n_C}\sum_{j=1}^{n_C}(G^{(S)}_{ij} - G^{(G)}_{ij})^2 \]</span></p>
<p>where <span class="math inline">\(G^{(S)}\)</span> and <span class="math inline">\(G^{(G)}\)</span> are respectively the Gram matrices of the &quot;style&quot; image and the &quot;generated&quot; image, computed using the hidden layer activations for a particular hidden layer in the network.</p>
<p><strong>Exercise</strong>: Compute the style cost for a single layer.</p>
<p><strong>Instructions</strong>: The 3 steps to implement this function are: 1. Retrieve dimensions from the hidden layer activations a_G: - To retrieve dimensions from a tensor X, use: <code>X.get_shape().as_list()</code> 2. Unroll the hidden layer activations a_S and a_G into 2D matrices, as explained in the picture above. - You may find <a target="_blank" rel="noopener" href="https://www.tensorflow.org/versions/r1.3/api_docs/python/tf/transpose">Hint1</a> and <a target="_blank" rel="noopener" href="https://www.tensorflow.org/versions/r1.2/api_docs/python/tf/reshape">Hint2</a> useful. 3. Compute the Style matrix of the images S and G. (Use the function you had previously written.) 4. Compute the Style cost: - You may find <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/reduce_sum">Hint3</a>, <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/square">Hint4</a> and <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/subtract">Hint5</a> useful.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GRADED FUNCTION: compute_layer_style_cost</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_layer_style_cost</span>(<span class="params">a_S, a_G</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    a_S -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing style of the image S </span></span><br><span class="line"><span class="string">    a_G -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing style of the image G</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns: </span></span><br><span class="line"><span class="string">    J_style_layer -- tensor representing a scalar value, style cost defined above by equation (2)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Retrieve dimensions from a_G (≈1 line)</span></span><br><span class="line">    m, n_H, n_W, n_C = a_G.get_shape().as_list()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Reshape the images to have them of shape (n_C, n_H*n_W) (≈2 lines)</span></span><br><span class="line">    a_S = tf.reshape(a_S, [ n_H * n_W, n_C])</span><br><span class="line">    a_G = tf.reshape(a_G, [ n_H * n_W, n_C])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Computing gram_matrices for both images S and G (≈2 lines)</span></span><br><span class="line">    GS = gram_matrix(tf.transpose(a_S))</span><br><span class="line">    GG = gram_matrix(tf.transpose(a_G))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Computing the loss (≈1 line)</span></span><br><span class="line">    J_style_layer = tf.reduce_sum(tf.square(tf.subtract(GS,GG))) / ((<span class="number">2</span> * n_C * n_H * n_W ) ** <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J_style_layer</span><br></pre></td></tr></table></figure>
<h5 id="style-weights">3.2.3 Style Weights</h5>
<p>So far you have captured the style from only one layer. We'll get better results if we &quot;merge&quot; style costs from several different layers. After completing this exercise, feel free to come back and experiment with different weights to see how it changes the generated image <span class="math inline">\(G\)</span>. But for now, this is a pretty reasonable default:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">STYLE_LAYERS = [</span><br><span class="line">    (<span class="string">&#x27;conv1_1&#x27;</span>, <span class="number">0.2</span>),</span><br><span class="line">    (<span class="string">&#x27;conv2_1&#x27;</span>, <span class="number">0.2</span>),</span><br><span class="line">    (<span class="string">&#x27;conv3_1&#x27;</span>, <span class="number">0.2</span>),</span><br><span class="line">    (<span class="string">&#x27;conv4_1&#x27;</span>, <span class="number">0.2</span>),</span><br><span class="line">    (<span class="string">&#x27;conv5_1&#x27;</span>, <span class="number">0.2</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You can combine the style costs <span class="keyword">for</span> different layers <span class="keyword">as</span> follows:</span><br><span class="line"></span><br><span class="line">$$J_&#123;style&#125;(S,G) = \sum_&#123;l&#125; \<span class="keyword">lambda</span>^&#123;[l]&#125; J^&#123;[l]&#125;_&#123;style&#125;(S,G)$$</span><br><span class="line"></span><br><span class="line">where the values <span class="keyword">for</span> $\<span class="keyword">lambda</span>^&#123;[l]&#125;$ are given <span class="keyword">in</span> `STYLE_LAYERS`. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We<span class="string">&#x27;ve implemented a compute_style_cost(...) function. It simply calls your `compute_layer_style_cost(...)` several times, and weights their results using the values in `STYLE_LAYERS`. Read over it to make sure you understand what it&#x27;</span>s doing. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_style_cost</span>(<span class="params">model, STYLE_LAYERS</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes the overall style cost from several chosen layers</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    model -- our tensorflow model</span></span><br><span class="line"><span class="string">    STYLE_LAYERS -- A python list containing:</span></span><br><span class="line"><span class="string">                        - the names of the layers we would like to extract style from</span></span><br><span class="line"><span class="string">                        - a coefficient for each of them</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns: </span></span><br><span class="line"><span class="string">    J_style -- tensor representing a scalar value, style cost defined above by equation (2)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize the overall style cost</span></span><br><span class="line">    J_style = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> layer_name, coeff <span class="keyword">in</span> STYLE_LAYERS:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Select the output tensor of the currently selected layer</span></span><br><span class="line">        out = model[layer_name]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set a_S to be the hidden layer activation from the layer we have selected, by running the session on out</span></span><br><span class="line">        a_S = sess.run(out)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set a_G to be the hidden layer activation from same layer. Here, a_G references model[layer_name] </span></span><br><span class="line">        <span class="comment"># and isn&#x27;t evaluated yet. Later in the code, we&#x27;ll assign the image G as the model input, so that</span></span><br><span class="line">        <span class="comment"># when we run the session, this will be the activations drawn from the appropriate layer, with G as input.</span></span><br><span class="line">        a_G = out</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute style_cost for the current layer</span></span><br><span class="line">        J_style_layer = compute_layer_style_cost(a_S, a_G)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add coeff * J_style_layer of this layer to overall style cost</span></span><br><span class="line">        J_style += coeff * J_style_layer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J_style</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: In the inner-loop of the for-loop above, <code>a_G</code> is a tensor and hasn't been evaluated yet. It will be evaluated and updated at each iteration when we run the TensorFlow graph in model_nn() below.</p>
<p><font color='blue'> <strong>What you should remember</strong>: - The style of an image can be represented using the Gram matrix of a hidden layer's activations. However, we get even better results combining this representation from multiple different layers. This is in contrast to the content representation, where usually using just a single hidden layer is sufficient. - Minimizing the style cost will cause the image <span class="math inline">\(G\)</span> to follow the style of the image <span class="math inline">\(S\)</span>. </font color='blue'></p>
<h5 id="defining-the-total-cost-to-optimize">3.3 - Defining the total cost to optimize</h5>
<p>Finally, let's create a cost function that minimizes both the style and the content cost. The formula is:</p>
<p><span class="math display">\[J(G) = \alpha J_{content}(C,G) + \beta J_{style}(S,G)\]</span></p>
<p><strong>Exercise</strong>: Implement the total cost function which includes both the content cost and the style cost.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#GRADED FUNCTION: total_cost</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_cost</span>(<span class="params">J_content, J_style, alpha = <span class="number">10</span>, beta = <span class="number">40</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes the total cost function</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    J_content -- content cost coded above</span></span><br><span class="line"><span class="string">    J_style -- style cost coded above</span></span><br><span class="line"><span class="string">    alpha -- hyperparameter weighting the importance of the content cost</span></span><br><span class="line"><span class="string">    beta -- hyperparameter weighting the importance of the style cost</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    J -- total cost as defined by the formula above.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈1 line)</span></span><br><span class="line">    J = alpha * J_content + beta * J_style</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> J</span><br></pre></td></tr></table></figure>
<p><font color='blue'> <strong>What you should remember</strong>: - The total cost is a linear combination of the content cost <span class="math inline">\(J_{content}(C,G)\)</span> and the style cost <span class="math inline">\(J_{style}(S,G)\)</span> - <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are hyperparameters that control the relative weighting between content and style </font color='blue'></p>
<h4 id="solving-the-optimization-problem">4 - Solving the optimization problem</h4>
<p>Finally, let's put everything together to implement Neural Style Transfer!</p>
<p>Here's what the program will have to do:</p>
<p><font color='purple'> 1. Create an Interactive Session 2. Load the content image 3. Load the style image 4. Randomly initialize the image to be generated 5. Load the VGG16 model 7. Build the TensorFlow graph: - Run the content image through the VGG16 model and compute the content cost - Run the style image through the VGG16 model and compute the style cost - Compute the total cost - Define the optimizer and the learning rate 8. Initialize the TensorFlow graph and run it for a large number of iterations, updating the generated image at every step. </font></p>
<p>Lets go through the individual steps in detail.</p>
<p>You've previously implemented the overall cost <span class="math inline">\(J(G)\)</span>. We'll now set up TensorFlow to optimize this with respect to <span class="math inline">\(G\)</span>. To do so, your program has to reset the graph and use an &quot;<a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/InteractiveSession">Interactive Session</a>&quot;. Unlike a regular session, the &quot;Interactive Session&quot; installs itself as the default session to build a graph. This allows you to run variables without constantly needing to refer to the session object, which simplifies the code.</p>
<p>Lets start the interactive session.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Reset the graph</span></span><br><span class="line">tf.reset_default_graph()</span><br><span class="line"></span><br><span class="line">Start interactive session</span><br><span class="line">sess = tf.InteractiveSession()</span><br></pre></td></tr></table></figure>
<p>Let's load, reshape, and normalize our &quot;content&quot; image (the Louvre museum picture):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">content_image = scipy.misc.imread(<span class="string">&quot;images/louvre_small.jpg&quot;</span>)</span><br><span class="line">content_image = reshape_and_normalize_image(content_image)</span><br></pre></td></tr></table></figure>
<p>Let's load, reshape and normalize our &quot;style&quot; image (Claude Monet's painting):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">style_image = scipy.misc.imread(<span class="string">&quot;images/monet.jpg&quot;</span>)</span><br><span class="line">style_image = reshape_and_normalize_image(style_image)</span><br></pre></td></tr></table></figure>
<p>Now, we initialize the &quot;generated&quot; image as a noisy image created from the content_image. By initializing the pixels of the generated image to be mostly noise but still slightly correlated with the content image, this will help the content of the &quot;generated&quot; image more rapidly match the content of the &quot;content&quot; image. (Feel free to look in <code>nst_utils.py</code> to see the details of <code>generate_noise_image(...)</code>; to do so, click &quot;File--&gt;Open...&quot; at the upper-left corner of this Jupyter notebook.)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">generated_image = generate_noise_image(content_image)</span><br><span class="line">imshow(generated_image[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>Next, as explained in part (2), let's load the VGG16 model.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model = load_vgg_model(<span class="string">&quot;pretrained-model/imagenet-vgg-verydeep-19.mat&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>To get the program to compute the content cost, we will now assign <code>a_C</code> and <code>a_G</code> to be the appropriate hidden layer activations. We will use layer <code>conv4_2</code> to compute the content cost. The code below does the following:</p>
<ol type="1">
<li>Assign the content image to be the input to the VGG model.</li>
<li>Set a_C to be the tensor giving the hidden layer activation for layer &quot;conv4_2&quot;.</li>
<li>Set a_G to be the tensor giving the hidden layer activation for the same layer.</li>
<li>Compute the content cost using a_C and a_G.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Assign the content image to be the input of the VGG model.  </span></span><br><span class="line">sess.run(model[<span class="string">&#x27;input&#x27;</span>].assign(content_image))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select the output tensor of layer conv4_2</span></span><br><span class="line">out = model[<span class="string">&#x27;conv4_2&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a_C to be the hidden layer activation from the layer we have selected</span></span><br><span class="line">a_C = sess.run(out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a_G to be the hidden layer activation from same layer. Here, a_G references model[&#x27;conv4_2&#x27;] </span></span><br><span class="line"><span class="comment"># and isn&#x27;t evaluated yet. Later in the code, we&#x27;ll assign the image G as the model input, so that</span></span><br><span class="line"><span class="comment"># when we run the session, this will be the activations drawn from the appropriate layer, with G as input.</span></span><br><span class="line">a_G = out</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the content cost</span></span><br><span class="line">J_content = compute_content_cost(a_C, a_G)</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: At this point, a_G is a tensor and hasn't been evaluated. It will be evaluated and updated at each iteration when we run the Tensorflow graph in model_nn() below.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assign the input of the model to be the &quot;style&quot; image </span></span><br><span class="line">sess.run(model[<span class="string">&#x27;input&#x27;</span>].assign(style_image))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the style cost</span></span><br><span class="line">J_style = compute_style_cost(model, STYLE_LAYERS)</span><br></pre></td></tr></table></figure>
<p><strong>Exercise</strong>: Now that you have J_content and J_style, compute the total cost J by calling <code>total_cost()</code>. Use <code>alpha = 10</code> and <code>beta = 40</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##### START CODE HERE ### (1 line)</span></span><br><span class="line">J = total_cost(J_content, J_style)</span><br><span class="line"><span class="comment">##### END CODE HERE ###</span></span><br></pre></td></tr></table></figure>
<p>You'd previously learned how to set up the Adam optimizer in TensorFlow. Lets do that here, using a learning rate of 2.0. <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer">See reference</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define optimizer (1 line)</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define train_step (1 line)</span></span><br><span class="line">train_step = optimizer.minimize(J)</span><br></pre></td></tr></table></figure>
<p><strong>Exercise</strong>: Implement the model_nn() function which initializes the variables of the tensorflow graph, assigns the input image (initial generated image) as the input of the VGG16 model and runs the train_step for a large number of steps.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_nn</span>(<span class="params">sess, input_image, num_iterations = <span class="number">200</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize global variables (you need to run the session on the initializer)</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Run the noisy input image (initial generated image) through the model. Use assign().</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">    sess.run(model[<span class="string">&#x27;input&#x27;</span>].assign(input_image))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Run the session on the train_step to minimize the total cost</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">        sess.run(train_step)</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute the generated image by running the session on the current model[&#x27;input&#x27;]</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### (1 line)</span></span><br><span class="line">        generated_image = sess.run(model[<span class="string">&#x27;input&#x27;</span>])</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print every 20 iteration.</span></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            Jt, Jc, Js = sess.run([J, J_content, J_style])</span><br><span class="line">            print(<span class="string">&quot;Iteration &quot;</span> + str(i) + <span class="string">&quot; :&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;total cost = &quot;</span> + str(Jt))</span><br><span class="line">            print(<span class="string">&quot;content cost = &quot;</span> + str(Jc))</span><br><span class="line">            print(<span class="string">&quot;style cost = &quot;</span> + str(Js))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># save current generated image in the &quot;/output&quot; directory</span></span><br><span class="line">            save_image(<span class="string">&quot;output/&quot;</span> + str(i) + <span class="string">&quot;.png&quot;</span>, generated_image)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># save last generated image</span></span><br><span class="line">    save_image(<span class="string">&#x27;output/generated_image.jpg&#x27;</span>, generated_image)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> generated_image</span><br></pre></td></tr></table></figure>
<p>Run the following cell to generate an artistic image. It should take about 3min on CPU for every 20 iterations but you start observing attractive results after ≈140 iterations. Neural Style Transfer is generally trained using GPUs.</p>
<p>You're done! After running this, in the upper bar of the notebook click on &quot;File&quot; and then &quot;Open&quot;. Go to the &quot;/output&quot; directory to see all the saved images. Open &quot;generated_image&quot; to see the generated image! :)</p>
<p>You should see something the image presented below on the right:</p>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/louvre_generated.png" class="" title="Louvre Generated">
<p>We didn't want you to wait too long to see an initial result, and so had set the hyperparameters accordingly. To get the best looking results, running the optimization algorithm longer (and perhaps with a smaller learning rate) might work better. After completing and submitting this assignment, we encourage you to come back and play more with this notebook, and see if you can generate even better looking images.</p>
<p>Here are few other examples:</p>
<ul>
<li>The beautiful ruins of the ancient city of Persepolis (Iran) with the style of Van Gogh (The Starry Night)</li>
</ul>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/perspolis_vangogh.png" class="" title="Perspolis Vangogh">
<ul>
<li>The tomb of Cyrus the great in Pasargadae with the style of a Ceramic Kashi from Ispahan.</li>
</ul>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/pasargad_kashi.png" class="" title="Pasargad Kashi">
<ul>
<li>A scientific study of a turbulent fluid with the style of a abstract blue fluid painting.</li>
</ul>
<img src="/2018/11/25/coursera-deeplearning-ai-c4-week4/circle_abstract.png" class="" title="Circle Abstract">
<h4 id="test-with-your-own-image-optionalungraded">5 - Test with your own image (Optional/Ungraded)</h4>
<p>Finally, you can also rerun the algorithm on your own images!</p>
<p>To do so, go back to part 4 and change the content image and style image with your own pictures. In detail, here's what you should do:</p>
<ol type="1">
<li>Click on &quot;File -&gt; Open&quot; in the upper tab of the notebook</li>
<li>Go to &quot;/images&quot; and upload your images (requirement: (WIDTH = 300, HEIGHT = 225)), rename them &quot;my_content.png&quot; and &quot;my_style.png&quot; for example.</li>
<li>Change the code in part (3.4) from : <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content_image = scipy.misc.imread(<span class="string">&quot;images/louvre.jpg&quot;</span>)</span><br><span class="line">style_image = scipy.misc.imread(<span class="string">&quot;images/claude-monet.jpg&quot;</span>)</span><br></pre></td></tr></table></figure> to: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content_image = scipy.misc.imread(<span class="string">&quot;images/my_content.jpg&quot;</span>)</span><br><span class="line">style_image = scipy.misc.imread(<span class="string">&quot;images/my_style.jpg&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>Rerun the cells (you may need to restart the Kernel in the upper tab of the notebook).</li>
</ol>
<p>You can also tune your hyperparameters: - Which layers are responsible for representing the style? STYLE_LAYERS - How many iterations do you want to run the algorithm? num_iterations - What is the relative weighting between content and style? alpha/beta</p>
<h4 id="conclusion">6 - Conclusion</h4>
<p>Great job on completing this assignment! You are now able to use Neural Style Transfer to generate artistic images. This is also your first time building a model in which the optimization algorithm updates the pixel values rather than the neural network's parameters. Deep learning has many different types of models and this is only one of them!</p>
<p><font color='blue'> What you should remember: - Neural Style Transfer is an algorithm that given a content image C and a style image S can generate an artistic image - It uses representations (hidden layer activations) based on a pretrained ConvNet. - The content cost function is computed using one hidden layer's activations. - The style cost function for one layer is computed using the Gram matrix of that layer's activations. The overall style cost function is obtained using several hidden layers. - Optimizing the total cost function results in synthesizing new images. </font color='blue'></p>
<p>This was the final programming exercise of this course. Congratulations--you've finished all the programming exercises of this course on Convolutional Networks! We hope to also see you in Course 5, on Sequence models!</p>
<h5 id="references">References:</h5>
<p>The Neural Style Transfer algorithm was due to Gatys et al. (2015). Harish Narayanan and Github user &quot;log0&quot; also have highly readable write-ups from which we drew inspiration. The pre-trained network used in this implementation is a VGG network, which is due to Simonyan and Zisserman (2015). Pre-trained weights were from the work of the MathConvNet team.</p>
<ul>
<li>Leon A. Gatys, Alexander S. Ecker, Matthias Bethge, (2015). A Neural Algorithm of Artistic Style (https://arxiv.org/abs/1508.06576)</li>
<li>Harish Narayanan, Convolutional neural networks for artistic style transfer. https://harishnarayanan.org/writing/artistic-style-transfer/</li>
<li>Log0, TensorFlow Implementation of &quot;A Neural Algorithm of Artistic Style&quot;. http://www.chioka.in/tensorflow-implementation-neural-algorithm-of-artistic-style</li>
<li>Karen Simonyan and Andrew Zisserman (2015). Very deep convolutional networks for large-scale image recognition (https://arxiv.org/pdf/1409.1556.pdf)</li>
<li>MatConvNet. http://www.vlfeat.org/matconvnet/pretrained/</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/deeplearning-ai/" rel="tag"># deeplearning.ai</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/03/caffe-source-code-analysis-1/" rel="prev" title="caffe_source_code_analysis_1">
      <i class="fa fa-chevron-left"></i> caffe_source_code_analysis_1
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/07/01/Tensorflow%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%AE%97%E5%AD%90%E6%B3%A8%E5%86%8C/" rel="next" title="Tensorflow源码解析——算子注册">
      Tensorflow源码解析——算子注册 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#face-recognition"><span class="nav-number">1.1.</span> <span class="nav-text">Face Recognition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what-is-face-recognition"><span class="nav-number">1.1.1.</span> <span class="nav-text">What is face recognition?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-shot-learning"><span class="nav-number">1.1.2.</span> <span class="nav-text">One Shot Learning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#siamese-network%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C"><span class="nav-number">1.1.3.</span> <span class="nav-text">Siamese Network（孪生网络）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#triplet-loss"><span class="nav-number">1.1.4.</span> <span class="nav-text">Triplet Loss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#face-verification-and-binary-classification"><span class="nav-number">1.1.5.</span> <span class="nav-text">Face Verification and Binary Classification</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#neural-style-transfer"><span class="nav-number">1.2.</span> <span class="nav-text">Neural Style Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what-is-neural-style-transfer"><span class="nav-number">1.2.1.</span> <span class="nav-text">What is neural style transfer?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#what-are-deep-convnets-learning"><span class="nav-number">1.2.2.</span> <span class="nav-text">What are deep ConvNets learning?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cost-function"><span class="nav-number">1.2.3.</span> <span class="nav-text">Cost Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#content-cost-function"><span class="nav-number">1.2.4.</span> <span class="nav-text">Content Cost Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#style-cost-function"><span class="nav-number">1.2.5.</span> <span class="nav-text">Style Cost Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-and-3d-generalizations"><span class="nav-number">1.2.6.</span> <span class="nav-text">1D and 3D Generalizations</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">编程练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deep-learning-art-neural-style-transfer"><span class="nav-number">2.1.</span> <span class="nav-text">Deep Learning &amp; Art: Neural Style Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#problem-statement"><span class="nav-number">2.1.1.</span> <span class="nav-text">1 - Problem Statement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer-learning"><span class="nav-number">2.1.2.</span> <span class="nav-text">2 - Transfer Learning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#neural-style-transfer-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">3 - Neural Style Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#computing-the-content-cost"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.1 - Computing the content cost</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#computing-the-style-cost"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.2 - Computing the style cost</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#style-matrix"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3.2.1 - Style matrix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#style-cost"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">3.2.2 - Style cost</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#style-weights"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">3.2.3 Style Weights</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defining-the-total-cost-to-optimize"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">3.3 - Defining the total cost to optimize</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#solving-the-optimization-problem"><span class="nav-number">2.1.4.</span> <span class="nav-text">4 - Solving the optimization problem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#test-with-your-own-image-optionalungraded"><span class="nav-number">2.1.5.</span> <span class="nav-text">5 - Test with your own image (Optional&#x2F;Ungraded)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#conclusion"><span class="nav-number">2.1.6.</span> <span class="nav-text">6 - Conclusion</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#references"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">References:</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张阿楠"
      src="/images/wukong.png">
  <p class="site-author-name" itemprop="name">张阿楠</p>
  <div class="site-description" itemprop="description">Keep codeing and thinking!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Vernlium" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Vernlium" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhanganan0425@163.com" title="E-Mail → mailto:zhanganan0425@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张阿楠</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '94b49fdac7c9894db657',
      clientSecret: 'aae2bc06bd829867f3212474d4698cfec26386d6',
      repo        : 'vernlium.github.io',
      owner       : 'Vernlium',
      admin       : ['Vernlium'],
      id          : 'bad9ed33b804ee484bf68b08e0eb9b22',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
